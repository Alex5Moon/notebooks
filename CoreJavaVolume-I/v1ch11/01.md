### 11.1 处理错误
- 假设在一个 Java 程序运行期间出现了一个错误。这个错误可能是由于文件包含了错误信息，或者网络连接出现问题造成的，也有可能是因为使用无效的数组下标，或者试图使用一个没有被赋值的对象引用而造成的。用户期望在出现错误时，程序能够采用一些理智的行为。如果由于出现错误而使得某些操作没有完成，程序应该：
- 1）返回到一种安全状态，并能够让用户执行一些其他的命令；或者
- 2）允许用户保存所有操作的结果，并以适当的方式终止程序。
- 要做到这些并不是一件很容易的事情。其原因是检测（或引发）错误条件的代码通常离那些能够让数据恢复到安全状态，或者能够保存用户的操作结果，并正常地退出程序的代码很远。异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理器。为了能够在程序中处理异常情况，必须研究程序中可能会出现的错误和问题，以及哪类问题需要关注。
- 1）用户输入错误
- 除了那些不可避免的键盘输入错误外，有些用户喜欢各行其是，不遵守程序的要求。例如，假设有一个用户请求连接一个 URL，而语法却不正确。在程序代码中应该对此进行检查，如果没有检查，网络层就会给出警告。
- 2）设备错误
- 硬件并不总是让它做什么，它就做什么。打印机可能被关掉了。网页可能临时性地不能浏览。在一个任务的处理过程中，硬件经常出现问题。例如，打印机在打印过程中可能没有纸了。
- 3）物理限制
- 磁盘满了，可用存储空间已被用完。
- 4）代码错误
- 程序方法有可能无法正确执行。例如，方法可能返回了一个错误的答案，或者错误地调用了其他的方法。
- 例如，对于一个从文件中读取信息的方法来说，返回值通常不是标准字符，而是一个 -1，表示文件结束。这种处理方式对于很多异常状况都是可行的。还有一种表示错误状况的常用返回值是 null 引用。
- 遗憾的是，并不是在任何情况下都能返回一个错误码。有可能无法明确地将有效数据与无效数据加以区分。一个返回整型的方法就不能简单地通过返回 -1 表示错误，因为 -1 很可能是一个完全合法的结果。
- 正如第 5 章中所叙述的那样，在 Java中，如果某个方法不能够采用正常的途径完整它的任务，就可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值，而是**抛出（throw）**一个封装了错误信息的对象。需要注意的是，这个方法将会立刻退出，并不返回任何值。此外，调用这个方法的代码也将无法继续执行，而是，异常处理机制开始搜索能够处理这种异常状况的**异常处理器（exception handler）**。
- 异常具有自己的语法和特定的继承结构。
> 
### 11.1.1 异常分类 
- 在Java 程序设计语言中，异常对象都是派生于 Throwable 类的一个实例。如果Java 中内置的异常类不能够满足需求，用户可以创建自己的异常类。
- Java异常层次结构的一个简化示意图。
- []()
- 需要注意的是，所有的异常都是由 Throwable继承而来，但在下一层立即分解为两个分支： Error 和 Exception
- Error 类层次结构描述了 Java运行时系统的内部错误和资源耗尽错误。应用程序不应该抛出这种类型的对象。如果出现了这样的内部错误，除了通告给用户，并尽力使程序安全地终止之外，再也无能为力了。这种情况很少出现。
- 在设计Java 程序时，需要关注 Exception 层次结构。这个层次结构又分解为两个分支：一个分支派生于 RuntimeException；另一个分支包含其他异常。划分两个分支的规则是：由程序错误导致的异常属于 RuntimeException；而程序本身没有问题，但由于像 I/O 错误这类问题导致的异常属于其他异常。
- 派生于 RuntimeException 的异常包含下面几种情况：
- 1）错误的类型转换
- 2）数组访问越界
- 3）访问空指针
- 不是派生于 RuntimeException 的异常包括：
- 1）试图在文件尾部后面读取数据。
- 2）试图打开一个不存在的文件。
- 3）试图根据给定的字符串查找 Class 对象，而这个字符串表示的类并不存在。
- “如果出现RuntimeException 异常，那么就一定是你的问题”是一条相当有道理的规则。应该通过检测数组下标是否越界来避免 ArrayIndexOutOfBoundsException 异常；应该通过在使用变量之前检测是否为空来杜绝 NullPointerException 异常的发生。
- 如何处理错误格式的 URL 呢？在使用 URL 之前，是否也需要尽可能地判断是否“具有错误格式”呢？事实上，不同的浏览器可以处理不同类别的 URL。例如， Netscape 可以处理 mailto:URL 格式，而applet 查看器就不能处理这种格式。因此，“具有错误格式”取决于具体的环境，而不仅仅是程序代码。
- Java 语言规范将派生于 Error 类或 RuntimeException 类的所有异常称为**未检查（unchecked）**异常，所有其他的异常称为**已检查（checked）**异常。这是很有用的术语。编译器将核查是否为所有的已检查异常提供了异常处理器。
> 
### 11.1.2 声明已检查异常
- 如果遇到了无法处理的情况，那么 Java 的方法可以抛出一个异常。这个道理很简单：一个方法不仅需要告诉编译器将要返回什么值，还要告诉编译器**有可能发生什么错误**。例如，一段读取文件的代码知道有可能读取的文件不存在，或者内容为空，因此，试图处理文件信息的代码就需要通知编译器可能会抛出 IOException 类的异常。
- 方法应该在其首部声明所有可能抛出的异常。这样可以从首部反映出这个方法可能抛出哪类已检查异常。例如，下面是标准类库中提供的 FileInputStream 类的一个构造器的声明。
- ` public FileInputStream(String name) throws FileNotFoundException `
- 这个声明表示这个构造器将根据给定的 String 参数产生一个 FileInputStream 对象，但也**有可能**抛出一个 FileNotFoundException 异常。如果发生了这种糟糕情况，构造器将不会初始化一个新的 FileInputStream 对象，而是抛出一个 FileNotFoundException 类对象。如果这个方法真的抛出了这样一个异常对象，运行时系统就会开始搜索异常处理器，以便知道如何处理 FileNotFoundException 对象。
- 在自己编写方法时，不必将所有可能抛出的异常都进行声明。至于什么时候需要在方法中用 throws 子句声明，什么异常必须使用 throws子句声明，需要记住要到下面 4 种情况时应该抛出异常：
- 1）调用一个抛出已检查异常的方法，例如，FileInputStream 构造器。
- 2）程序运行过程中发现错误，并且利用 throw 语句抛出一个已检查异常
- 3）程序出现错误，例如，a[-1] = 0 会抛出一个 ArrayIndexOutOfBoundsException 这样的未检查异常。
- 4）Java 虚拟机和运行时库出现的内部错误。
- 如果出现前两种情况之一，则必须告诉调用这个方法的程序员有可能抛出异常。因为任何一个抛出异常的方法都有可能是一个死亡陷阱。如果没有处理器捕获这个异常，当前执行的线程就会结束。
- 对于那些可能被他人使用的 Java方法，应该根据**异常规范（exception specification）**，在方法的首部声明这个方法可能抛出的异常。
```
  class MyAnimation{
    ...
    public Image loadImage(String s) throws IOException{
      ...
    }
    ...
  }
  
```
- 如果一个方法有可能抛出多个已检查异常，那么就必须在方法的首部列出所有的异常类。每个异常类之间用逗号隔开。如下面这个例子所示：
```
  class MyAnimation{
    ...
    public Image loadImage(String s) throws FileNotFoundException,EOFException{
      ...
    }
    ...
  }
    
```
- 但是，不需要声明Java 的内部错误，即从 Error 继承的错误。任何程序代码都具有抛出那些异常的潜能，而我们对其没有任何控制能力。
- 同样，也不应该声明从 RuntimeException 继承的那些未检查异常。
```
  class MyAnimation{
    ...
    void dramImage(int i) throws ArrayIndexOfBoundsException {            // bad style 
      ...
    }
    ...
  }  
```
- 这些运行时错误完全在我们的控制之下。如果特别关注数组下标引发的错误，就应该将更多的时间花费在修正程序中的错误上，而不是说明这些错误发生的可能性上。
- 总之，一个方法必须声明所有可能抛出的**已检查异常**，而未检查异常要么不可控制（Error），要么就应该避免发生（RuntimeException）。如果方法没有声明所有可能发生的已检查异常，编译器就会给出一个错误信息。
- 当然，从前面的示例中可以知道：除了声明异常之外，还可以捕获异常。这样会使异常不抛到方法之外，也不需要 throws 规范。稍后，将讨论如何决定一个异常是被捕获，还是被抛出让其他的处理器进行处理。
- **警告**：如果在子类中覆盖了超类的一个方法，子类方法中声明的已检查异常不能比超类方法中声明的异常更通用（也就是说，子类中可以抛出更特定的异常，或者根本不抛出任何异常）。特别需要说明的是，如果超类方法没有抛出任何已检查异常，子类也不能抛出任何已检查异常。
- 如果类中一个方法声明将会抛出一个异常，而这个异常是某个特定类的实例时，则这个方法就有可能抛出一个这个类的异常，或者这个类的任意一个子类的异常。例如，FileInputStream 构造器声明将有可能抛出一个 IOException异常，然而并不知道具体是哪种 IOException异常。它既可能是 IOException 异常，也可能是其子类的异常。例如，FileNotFoundException。
> 
### 11.1.3 如何抛出异常

















