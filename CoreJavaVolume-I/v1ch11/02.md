### 11.2 捕获异常
- 到目前为止，已经知道如何抛出一个异常。这个过程十分容易，只要将其抛出就不用理睬了。当然，有些代码必须捕获异常。捕获异常需要进行周密的计划。
- 如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息，其中包括异常的类型和堆栈的内容。
- 要想捕获一个异常，必须设置 try/catch 语句块。最简单的 try 语句块如下：
```
  try {
    code 
    more code
    more code
  } catch (ExceptionType e) {
    handler for this type
  }
```
- 如果在try 语句块中的任何代码抛出了一个在 catch 子句中说明的异常类，那么
- 1）程序将跳过 try 语句块的其余代码。
- 2）程序将执行catch 子句中的处理器代码。
- 如果在 try 语句块中的代码没有抛出任何异常，那么程序将跳过 catch 子句。
- 如果方法中的任何代码抛出了一个在catch 子句中没有声明的异常类型，那么这个方法就会立刻退出（希望调用者为这种类型的异常设计了 catch 子句）
- 为了演示捕获异常的处理过程，下面给出一个读取文本的典型程序代码：
```
  public void read(String filename) { 
    try {
      InputStream in = new FileInputStream(filename);
      int b;
      while ((b = in.read()) != -1) {
        process input
      }
    } catch (IOException exception) {
      exception.printStackTrace();
    }
  }
```
- 需要注意的是，try 语句中的大多数代码都很容易理解：读取并处理文本行，知道遇到文件结束符为止。正如在 Java API 中看到的那样，read 方法有可能抛出一个 IOException 异常。在这种情况下，将跳出整个 while 循环，进入 catch子句，并生成一个栈轨迹。对于一个普通的程序来说，这样处理异常基本上合乎情理。还有其他的选择吗？
- 通常，最好的选择是什么也不做，而是将异常传递给调用者。如果 read 方法出现了错误，就让 read 方法的调用者去操心！如果采用这种处理方式，就必须声明这个方法可能会抛出一个 IOException。
```
  public void read(String filename) throws IOException { 
     
      InputStream in = new FileInputStream(filename);
      int b;
      while ((b = in.read()) != -1) {
        process input
      }
  }  
```
- 请记住，编译器严格地执行 throws 说明符。如果调用了一个抛出已检查异常的方法，就必须对它进行处理，或者将它继续进行传递。
- 哪种方法更好呢？通常，应该捕获那些知道如何处理的异常，而将那些不知道怎样处理的异常继续进行传递。如果想传递一个异常，就必须在方法的首部添加一个 throws 说明符，以便告知调用者这个方法可能会抛出异常。
- 仔细阅读以下 Java API 文档，以便知道每个方法可能会抛出哪种异常，然后再决定是自己处理，还是添加到 throws 列表中。对于后一种情况，也不必犹豫。将异常直接交给能够胜任的处理器进行处理要比压制对它的处理更好。
- 同时请记住，这个规则也有一个例外。前面曾经提到过：如果编写一个覆盖超类的方法，而这个方法又没有抛出异常，那么这个方法就必须捕获方法代码中出现的每一个已检查异常。不允许在子类的throws 说明符中出现超过超类方法所列出的异常类范围。
> 
### 11.2.1 捕获多个异常
- 在一个try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理，可以按照下列方式为每个异常类型使用一个单独的 catch 子句：
```
  try {
    code that might exceptions
  } catch (FileNotFoundException e){
    emergency action for missing files
  } catch (UnknownHostException e){
    emergency action for unknown hosts
  } catch (IOException e){
    emergency action for all other I/O problems 
  }
```
- 异常对象可能包含与异常本身有关的信息。要想获得对象的更多信息，可以试着使用
- ` e.getMessage() `
- 得到详细的错误信息，或者使用
- ` e.getClass().getName()`
- 得到异常对象的实际类型。
- 在 Java SE 7 中，同一个catch 子句中可以捕获多个异常类型。例如，假设对应缺少文件和未知主机异常的动作是一样的，就可以合并catch 子句：
```
  try {
    code that might exceptions
  } catch (FileNotFoundException | UnknownHostException e){
    emergency action for missing files and unknown hosts
  } catch (IOException e){
    emergency action for all other I/O problems 
  }
```
- 只有当捕获的异常类型彼此之间不存在子类关系时才需要这个特性。
> 
### 11.2.2 再次抛出异常与异常链
- 在 catch 子句中可以抛出一个异常，这样做的目的是改变异常的类型。如果开发了一个供其他程序员使用的子系统，那么，用于表示子系统故障的异常类型可能会产生多种解释。ServletException 就是这样一个异常类型的例子。执行 servlet 的代码可能不想知道发生错误的细节原因，但希望明确地知道servlet是否有问题。
- 下面给出了捕获异常并将它再次抛出的基本方法：
```
  try {
    access the database
  } catch (SQLException e) {
    throw new ServletException("database error: " + e.getMessage());
  }
```
- 这里ServletException 用带有异常信息文本的构造器来构造。不过，可以有一种更好的处理方法，并且将原始异常设置为新异常的 “原因”：























