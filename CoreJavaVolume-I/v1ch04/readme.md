## 对象与类
> 面向对象程序设计与面向过程程序设计在思维方式上存在着很大的差别。改变一种思维方式并不是一件很容易的事情，而且为了继续学习Java也要弄清楚对象的概念。
### 4.2 面向对象程序设计概述
- 面向对象程序设计（简称OOP）是当今主流的程序设计范型。Java是完全面向对象的，必须熟悉OOP才能够编写Java程序。
> 面向对象的程序是由对象组成的，每个对象包含对用户公开的特定功能部分和隐藏的实现部分。程序中的很多对象来自标准库，还有一些是自定义的。究竟是自己构造对象，还是从外界购买对象完全取决于开发项目的预算和时间。但是，从根本上说，只要对象能够满足要求，就不必关心其功能的具体实现过程。在OOP中，不必关心对象的具体实现，只要能够满足用户的需求即可。
> 
> 传统的结构化程序设计通过设计一系列的过程（即算法）来求解问题。一旦确定了这些过程，就要开始考虑存储数据的方式。这就是Pascal 语言的设计者 Niklaus Wirth 将其著作命名为《算法 + 数据结构 = 程序》（ Algorithms + Data Structures = Programs,Prentice Hall,1975）的原因。需要注意的是，在 Wirth命名的书名中，算法是第一位的，数据结构是第二位的，这就表述了程序员的工作方式。首先要确定如何操作数据，然后再决定如何组织数据，以便于数据操作。而OOP 却调换了这个次序，将数据放在第一位，然后再考虑操作数据的算法。
> 
> 对于一些规模较小的问题，将其分解为过程的开发方式比较理想。而面向对象更加使用于解决规模较大的问题。要想实现一个简单的Web 浏览器可能需要大约 2000个过程，这些过程可能需要对一组全局数据进行操作。采用面向对象的设计风格，可能只需要大约100个类，每个类平均包含20个方法（如下图所示）。后者更易于程序员掌握，也容易找到bug。假设给定对象的数据出错了，在访问过这个数据项的 20 个方法中查找错误要比在2000 个过程中查找容易得多。
> ![1]()
### 4.2.1 类
> 类（Class）是构造对象的模板或蓝图。我们可以将类想象成制作小甜饼的切割机，将对象想象为小甜饼。由类**构造（construct）**对象的过程称为创建类的**实例（instance）**。
>  
> 封装（encapsulation，有时称为数据隐藏）是与对象有关的一个重要概念。从形式上看，封装不过是将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式。对象中的数据称为**实例域（instance field）**，操纵数据的过程称为**方法（method）**。对于每个特定的类实例（对象）都有一组特定的实例域值。这些值的集合就是这个对象的当前**状态（state）**。无论何时，只要向对象发送一个消息，它的状态就有可能发送改变。
> 
> 实现封装的关键在于**绝对不能**让类中的方法直接访问其他类的实例域。程序仅通过对象的方法与对象数据进行交互。封装给对象赋予了“黑盒”的特征，这个提高重用性和可靠性的关键。这意味着一个类可以全面地改变存储数据的方式，只要仍旧使用同样的方法操作数据，其他对象就不会知道或介意所发生的变化。
> 
> OOP的另一个原则会让用户自定义Java类变得轻而易举，这就是：可以通过扩展一个类来建立另外一个新的类。事实上，在Java中，所有的类都源自于一个“神通广大的超类”，它就是 Object。下一章有详细介绍。
> 
> 在扩展一个已有的类时，这个扩展后的新类具有所扩展的类的全部属性和方法。在新类中，只需要提供适用于这个新类的新方法和数据域就可以了。通过扩展一个类来建立另外一个类的过程称为**继承（inheritance）**，下一章介绍。
### 4.2.2 对象
- 要想使用OOP，一定要清楚对象的三个主要特性：
1. 对象的行为（behavior）——可以对对象施加哪些操作，或可以对对象施加哪些方法？
2. 对象的状态（state）——当施加那些方法时，对象如何响应？
3. 对象标识（identity）——如何辨别具有相同行为与状态的不同对象？
> 同一个类的所有对象实例，由于支持相同的行为而具有家族式的相似性。对象的行为是用可调用的方法定义的。
> 
> 此外，每个对象都保存着描述当前特征的信息。这就是对象的状态。对象的状态可能会随着时间而发生改变，但这种改变不会是自发的。对象状态的改变必须通过调用方法实现（如果不经过方法调用就可以改变对象状态，只能说明封装性遭到了破坏）。
> 
> 但是，对象的状态并不能完全描述一个对象。每个对象都有一个唯一的身份（identity）。例如，在一个订单处理系统中，任何两个订单都存在着不同之处，即使所订购的货物完全相同也是如此。需要注意的是，作为一个类的实例，每个对象的标识**永远**是不同的，状态**常常**存在着差异。
> 
> 对象的这些关键特性在彼此之间相互影响着。例如，对象的状态影响它的行为（如果一个订单“已送货”或“已付款”，就应该拒绝调用具有增删订单中条目的方法。反过来，如果订单是“空的”，即还没有加入预订的物品，这个订单就不应该进入“已送货”状态）。（如果一个人的信用卡的账单金额是0，就应该拒绝调用还款类方法。反过来，如果信用卡账单金额大于0，拒绝调用账户重置方法，如果账单金额达到最大额度，拒绝调用支付方法）（一个人住院状态不允许结算门诊）
### 4.2.3 识别类
> 传统的过程化程序设计，必须从顶部的main 函数开始编写程序。在面向对象程序设计时没有所谓的“顶部”。对于学习OOP 的初学者来说常常会感觉无从下手。答案是：**首先从设计类开始，然后再往每个类中添加方法。**
> 
> 识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
> 
> 例如，在订单处理系统中，有这样一些名词：
- 项目（Item）
- 订单（Order）
- 送货地址（Shipping address）
- 付款（Payment）
- 账户（Account）
> 这些名词很可能成为类 Item、Order等。
> 
> 接下来，查看动词：物品项目被添加到订单中，订单被发送或取消，订单货款被支付。对于每一个动词如：“添加”、“发送”、“取消”以及“支付”，都要标记出主要负责完成相应动作的对象。例如，当一个新的条目添加到订单中时，那个订单对象就是被指定的对象，因为它知道如何存储条目以及如何对条目进行排序。也就是说，add应该是Order 类的一个方法，而 Item 对象是一个参数。
### 4.2.4 类之间的关系
- 在类之间，最常见的关系有
1. 依赖（“uses-a”）
2. 聚合（“has-a”）
3. 继承（“is-a”）
> 依赖（dependence），即 “uses-a” 关系，是一种最明显的、最常见的关系。例如，Order类使用Account 类是因为Order 对象需要访问Account 对象查看信用状态。但是Item 类不依赖于 Account类，这是因为Item 对象与客户账户无关。如果一个类的方法操纵另一个类的对象，我们就说一个类依赖于另一个类。
> 
> 应该尽可能地将相互依赖的类减至最少。如果类A 不知道 B 的存在，它就不会关心 B 的任何改变（这意味着 B 的改变不会导致 A 产生任何 bug）。用软件工程的术语来说，就是让类之间的耦合度最小。
> 
> 聚合（aggregation），即 “has-a” 关系，是一种具体且易于立即的关系。例如，一个Order 对象包含一些 Item 对象。 聚合关系意味着类A的对象包含类B的对象。
> 
> 继承（inheritance），即 “is-a” 关系，是一种用于表示特殊与一般关系的。例如，RushOrder 类由 Order 类继承而来。在具有特殊性的 RushOrder类中包含了一些用于优先处理的特殊方法，以及一个计算运费的不同方法（电子产品不需要运费）；而其他的方法，如添加条目、生成账单等都是从 Order类继承来的。一般而言，如果类A 扩展 类B，类A 不但从类B 继承的方法，还会拥有一些额外的功能。
> 
> 很多程序员采用 UML（Unified Modeling Language，统一建模语言）绘制类图，用来描述类之间的关系。类用矩形表示，类之间的关系用带有各种修饰符的箭头表示。
- ![]()
- ![]()

> 注意不要编写返回引用可变对象的访问器方法。在Employee类中就违反了这个设计原则。如果需要返回一个可变对象的引用，应该首先对她进行克隆（clone）

### Java程序设计语言总是采用按值调用。（程序清单 4-4）
- 一个方法不能修改一个基本数据类型的参数（即数值型和布尔型）
- 一个方法可以改变一个对象参数的状态
- 一个方法不能让对象参数引用一个新的对象

### 对象构造
> 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法。

### 初始化块（initialization block）
> 在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。首先运行初始化块，然后才运行构造器的主体部分。

### 类设计技巧
1. 一定要保证数据私有。
2. 一定要对数据初始化。
3. 不用再类中使用过多的基本类型。
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解
6. 类名和方法名要能够体现她们的职责。
