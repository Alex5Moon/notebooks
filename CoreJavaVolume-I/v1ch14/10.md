### 14.10 同步器
- java.util.concurrent 包包含了几个能帮助人们管理相互合作的线程集的类如下：
- CyclicBarrier     允许线程集等待直至其中预定数目的线程到达一个公共障栅（barrier），然后可以选择执行一个处理障栅的动作。
-                   当大量的线程需要在它们的结果可用之前完成时
- CountDownLatch    允许线程集等待直到计数器减为0
-                   当一个或多个线程需要等待直到指定书目的事件发生
- Exchanger         允许两个线程在要交换的对象准备好时交换对象
-                   当两个线程工作在同一数据结构的两个实例上的时候，一个向实例添加数据而另一个从实例清除数据
- Semaphore         允许线程集等待直到被允许继续运行为止
-                   限制访问资源的线程总数。如果许可数是1，常常阻塞线程直到另一个线程给出许可为止
- SynchronousQueue  允许一个线程把对象交给另一个线程
-                   在没有显式同步的情况下，当两个线程准备好将一个对象从一个线程传递到另一个时
- 这些机制具有为线程之间的**共用集结点模式**（common rendezvous patterns）提供的“预置功能”（canned functionality）。如果有一个相互合作的线程集满足这些行为模式之一，那么应该直接重用合适的库类而不要试图提供手工的锁与条件的集合。
> 
### 14.10.1 信号量
- 概念上讲，一个信号量管理许多的**许可证**（permits）。为了通过信号量，线程通过调用acquire请求许可。其实没有实际的许可对象，信号量仅维护一个计数。...
- 
- 
### 14.10.2 倒计时门栓
-
### 14.10.3 障栅
-
### 14.10.4 交换器
- 当两个线程在同一个数据缓冲区的两个实例上工作的时候，就可以使用**交换器**（Exchanger）。典型的情况是，一个线程向缓冲区填入数据，另一个线程消耗这些数据。当它们都完成以后，相互交换缓冲区。
### 14.10.5 同步队列
- 同步队列是一种将生产者与消费者线程配对的机制。当一个线程调用 SynchronousQueue 的put 方法时，它会阻塞直到另一个线程调用take方法为止，反之亦然。与Exchanger的情况不同，数据仅仅沿一个方向传递，从生产者到消费者。
- 即使 SynchronousQueue 类实现了 BlockingQueue 接口，概念上讲，它亦然不是一个队列。它没有包含任何元素，它的size方法总是返回0。
