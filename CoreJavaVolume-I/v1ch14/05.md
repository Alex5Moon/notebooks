### 14.5 同步
- 在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象，线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为**竞争条件**（race condition）。
### 14.5.1 竞争条件的一个例子
- 为了避免多线程引起的对共享数据的讹误，必须学习如何**同步存取**。在本节中，你会看到如果没有使用同步会发生什么。在下一节中，将会看到如何同步数据存取。
- 在下面的测试程序中，模拟一个有若干账户的银行。随机地生成在这些账户之间转移钱款的交易。每一个账户有一个线程。每一笔交易中，会从线程所服务的账户中随机转移一定数目的钱款到另一个随机账户。
- 模拟代码非常直观。我们具有 transfer 方法的 Bank 类。该方法从一个账户转移一定数目的钱款到另一个账户（还没有考虑负的账户余额）。如下是 Bank 类的 transfer 方法的代码。
```
  public void transfer(int from, int to, double amount) {
    // CAUTION: unsafe when called from multiple threads
    System.out.print(Thread.currentThread());
    accounts[from] -= amount;
    System.out.printf(" %10.2f from %d to %d", amount, from, to);
    accounts[to] += amount;
    System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
  }
```
- 这里是 TransferRunnable 类的代码。它的 run 方法不断地从一个固定的银行账户取出钱款。在每一次迭代中，run 方法随机选择一个目标账户和一个随机账户，调用 bank 对象的 transfer 方法，然后睡眠。
```
  class TransferRunnable implements Runnable {
    ...
    public void run(){
      try {
        int toAccount = (int)(bank.size() * Math.random());
        double amount = maxAmount * Math.random();
        bank.transfer(fromAccount, toAccount, amount);
        Thread.sleep((int)(DELAY * Math.random()));
      } catch (InterruptedException e) {
        
      }
    }
  }

```
- 当这个模拟程序运行时，不清楚在某一时刻某一银行账户中有多少钱。但是，知道所有账户的总金额应该保持不变，因为所做的一切不过是从一个账户转移钱款到另一个账户。
- 在每一次交易的结尾，transfer 方法重新计算总值并打印出来。
- 本程序用于不会结束。只能按 CTRL+C 来终止这个程序。
- 下面是典型的输出：
- ......
- 正如前所示，出现了错误。在最初的交易中，银行的余额保持在 $100000，这是正确的，因为共 100 个账户，每个账户 $1000。但是，过一段时间，余额总量有轻微的变化。当运行这个程序的时候，会发现有时很快就出错了，有时很长时间后余额发生混乱。这样的状态不会带来信任感，人们很可能不愿意将辛苦挣来的钱存到这个银行。
- [Bank.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/unsynch/Bank.java) 、[TransferRunnable.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/unsynch/TransferRunnable.java) 、 [UnsynchBankTest.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/unsynch/UnsynchBankTest.java) 提供了完全的源代码。看看是否可以从代码中找出外面。下一节将解说其中神秘。
### 14.5.2 竞争条件详解
- 上一节中运行了一个程序，其中有几个线程更新银行账户余额。一段时间之后，错误不知不觉地出现了，总额要么增加了，要么变少。当两个线程试图同时更新同一个账户的时候，这个问题就出现了。假定两个线程同时执行指令
- ` accounts[to] += amount; `
- 问题在于这不是原子操作。该指令可能被处理如下：
- 1）将accounts[to] 加载到寄存器。
- 2）增加amount。
- 3）将结果写回accounts[to]。
- 现在，假定第1个线程执行步骤1和2，然后，它被剥夺了运行权。假定第2个线程被唤醒并修改了accounts数组中的同一项。然后，第1个线程被唤醒并完成其第3步。
- 这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。（见图14-4）
- ![2](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/pic/2.png)
- 我们的测试程序检测到这一讹误。（当然，如果线程在运行这一测试时被中断，也有可能会出现失败警告！）
- **注释**：可以具体看一下执行我们的类中每一个语句的虚拟机的字节码。运行命令  javap -c -v Bank 
- 对 Bank.class 文件进行反编译。例如，代码行 
- ` accounts[to] += amount; `
- 被转换为下面的字节码：
```
  aload_0 
  getfield    #2; // Field accounts:[D
  iload_2
  dup2
  daload
  dload_3
  dadd
  dastore
```
- 这些代码的含义无关紧要。**重要的是增值命令是几条指令组成的，执行它们的线程可以在任何一条指令点上被中断。**
- 出现这一讹误的可能性有多大呢？这里通过将打印语句和更新余额的语句交织在一起执行，增加了发生这种情况的机会。
- 如果删除打印语句，讹误的风险会降低一点，因为**每个线程在再次睡眠之前所做的工作很少，调度器在计算过程中剥夺线程的运行权可能性很小。**但是，讹误的风险并没有完全消失。如果在负载很重的机器上运行许多线程，那么，即使删除了打印语句，程序依然会出错。这种错误可能会几分钟、几小时或几天出现一次。坦白地说，**对程序员而言，很少有比无规律出现错误更糟的事情了。**
- 真正的问题是 transfer 方法的执行过程中可能会被中断。如果能够确保线程在失去控制之前方法运行完成，那么银行账户对象的状态永远不会出现讹误。
### 14.5.3 锁对象
-
### 14.5.4 条件对象
-
### 14.5.5 synchronized 关键字
- 
### 14.5.6 同步阻塞
- 
### 14.5.7 监视器概念
- 
### 14.5.8 Volatile 域
- 
### 14.5.9 final 变量
- 
### 14.5.10 原子性
- 
### 14.5.11 死锁
- 
### 14.5.12 线程局部变量
-
### 14.5.13 锁测试与超时
- 
### 14.5.14 读/写锁
- 
### 14.5.15 为什么弃用stop和suspend方法
- 
