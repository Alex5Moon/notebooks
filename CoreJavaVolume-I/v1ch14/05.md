### 14.5 同步
- 在大多数实际的多线程应用中，两个或两个以上的线程需要共享对同一数据的存取。如果两个线程存取相同的对象，并且每一个线程都调用了一个修改该对象状态的方法，将会发生什么呢？可以想象，线程彼此踩了对方的脚。根据各线程访问数据的次序，可能会产生讹误的对象。这样一个情况通常称为**竞争条件**（race condition）。
### 14.5.1 竞争条件的一个例子
- 为了避免多线程引起的对共享数据的讹误，必须学习如何**同步存取**。在本节中，你会看到如果没有使用同步会发生什么。在下一节中，将会看到如何同步数据存取。
- 在下面的测试程序中，模拟一个有若干账户的银行。随机地生成在这些账户之间转移钱款的交易。每一个账户有一个线程。每一笔交易中，会从线程所服务的账户中随机转移一定数目的钱款到另一个随机账户。
- 模拟代码非常直观。我们具有 transfer 方法的 Bank 类。该方法从一个账户转移一定数目的钱款到另一个账户（还没有考虑负的账户余额）。如下是 Bank 类的 transfer 方法的代码。
```
  public void transfer(int from, int to, double amount) {
    // CAUTION: unsafe when called from multiple threads
    System.out.print(Thread.currentThread());
    accounts[from] -= amount;
    System.out.printf(" %10.2f from %d to %d", amount, from, to);
    accounts[to] += amount;
    System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());
  }
```
- 这里是 TransferRunnable 类的代码。它的 run 方法不断地从一个固定的银行账户取出钱款。在每一次迭代中，run 方法随机选择一个目标账户和一个随机账户，调用 bank 对象的 transfer 方法，然后睡眠。
```
  class TransferRunnable implements Runnable {
    ...
    public void run(){
      try {
        int toAccount = (int)(bank.size() * Math.random());
        double amount = maxAmount * Math.random();
        bank.transfer(fromAccount, toAccount, amount);
        Thread.sleep((int)(DELAY * Math.random()));
      } catch (InterruptedException e) {
        
      }
    }
  }

```
- 当这个模拟程序运行时，不清楚在某一时刻某一银行账户中有多少钱。但是，知道所有账户的总金额应该保持不变，因为所做的一切不过是从一个账户转移钱款到另一个账户。
- 在每一次交易的结尾，transfer 方法重新计算总值并打印出来。
- 本程序用于不会结束。只能按 CTRL+C 来终止这个程序。
- 下面是典型的输出：
- ......
- 正如前所示，出现了错误。在最初的交易中，银行的余额保持在 $100000，这是正确的，因为共 100 个账户，每个账户 $1000。但是，过一段时间，余额总量有轻微的变化。当运行这个程序的时候，会发现有时很快就出错了，有时很长时间后余额发生混乱。这样的状态不会带来信任感，人们很可能不愿意将辛苦挣来的钱存到这个银行。
- [Bank.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/unsynch/Bank.java) 、[TransferRunnable.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/unsynch/TransferRunnable.java) 、 [UnsynchBankTest.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/unsynch/UnsynchBankTest.java) 提供了完全的源代码。看看是否可以从代码中找出外面。下一节将解说其中神秘。
### 14.5.2 竞争条件详解
- 上一节中运行了一个程序，其中有几个线程更新银行账户余额。一段时间之后，错误不知不觉地出现了，总额要么增加了，要么变少。当两个线程试图同时更新同一个账户的时候，这个问题就出现了。假定两个线程同时执行指令
- ` accounts[to] += amount; `
- 问题在于这不是原子操作。该指令可能被处理如下：
- 1）将accounts[to] 加载到寄存器。
- 2）增加amount。
- 3）将结果写回accounts[to]。
- 现在，假定第1个线程执行步骤1和2，然后，它被剥夺了运行权。假定第2个线程被唤醒并修改了accounts数组中的同一项。然后，第1个线程被唤醒并完成其第3步。
- 这样，这一动作擦去了第二个线程所做的更新。于是，总金额不再正确。（见图14-4）
- ![2](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/pic/2.png)
- 我们的测试程序检测到这一讹误。（当然，如果线程在运行这一测试时被中断，也有可能会出现失败警告！）
- **注释**：可以具体看一下执行我们的类中每一个语句的虚拟机的字节码。运行命令  javap -c -v Bank 
- 对 Bank.class 文件进行反编译。例如，代码行 
- ` accounts[to] += amount; `
- 被转换为下面的字节码：
```
  aload_0 
  getfield    #2; // Field accounts:[D
  iload_2
  dup2
  daload
  dload_3
  dadd
  dastore
```
- 这些代码的含义无关紧要。**重要的是增值命令是几条指令组成的，执行它们的线程可以在任何一条指令点上被中断。**
- 出现这一讹误的可能性有多大呢？这里通过将打印语句和更新余额的语句交织在一起执行，增加了发生这种情况的机会。
- 如果删除打印语句，讹误的风险会降低一点，因为**每个线程在再次睡眠之前所做的工作很少，调度器在计算过程中剥夺线程的运行权可能性很小。**但是，讹误的风险并没有完全消失。如果在负载很重的机器上运行许多线程，那么，即使删除了打印语句，程序依然会出错。这种错误可能会几分钟、几小时或几天出现一次。坦白地说，**对程序员而言，很少有比无规律出现错误更糟的事情了。**
- 真正的问题是 transfer 方法的执行过程中可能会被中断。如果能够确保线程在失去控制之前方法运行完成，那么银行账户对象的状态永远不会出现讹误。
### 14.5.3 锁对象
- 有两种机制防止代码块受并发访问的干扰。Java语言提供一个 synchronized 关键字达到这一目的，并且Java SE 5.0 引入了 ReentrantLock 类。synchronized 关键字自动提供一个锁以及相关的“条件”，对于大多数需要显示锁的情况，这是很便利的。但是，我们相信在读者分别阅读了锁和条件的内容后，立即 synchronized 关键字是很轻松的事情。 java.util.concurrent 框架为这些基础机制提供独立的类，在此以及第 14.5.4 节加以解释这个内容。读者理解了这些构建块之后，将讨论第 14.5.5 节。
- 用 ReentrantLock 保护代码块的基本结构如下：
```
  myLock.lock();  // a ReentrantLock object
  try {
    critical section
  } finally {
    myLock.unlock();  // make sure the lock is unlocked even if an exception is thrown
  }
```
- 这一结构确保任何时刻只有一个线程进入临界区。一旦一个线程封锁了锁对象，其他任何线程都无法通过lock语句。当其他线程调用lock时，它们被阻塞，直到第一个线程释放锁对象。
- **警告**：把解锁操作括在finally子句之内是至关重要的。如果在临界区的代码抛出异常，锁必须被释放。否则，其他线程将永远阻塞。
- **注释**：如果使用锁，就不能使用带资源的try语句。首先，解锁的方法名不是close。不过，即使将它重命名，带资源的try语句也无法正常工作。它的首部希望声明一个新变量。但是如果使用一个锁，你可能想使用多个线程共享的那个变量（而不是新变量）。
- 让我们使用一个锁来保护 Bank 类的 transfer 方法。
```
  public class Bank {
    private Lock bankLock = new ReentrantLock();  // ReentrantLock implements the Lock interface
    ...
    public void transfer(int from, int to, int amount){
      bankLock.lock();
      try {
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d", amount, from, to);
        accounts[to] += amount;
        System.out.printf(" Total Balance: %10.2f%n", getTotalBalance());        
      } finally {
        bankLock.unlock();
      }
      
    }
  }
```
- 假定一个线程调用transfer，在执行结束前被剥夺了运行权。假定第二个线程也调用 transfer，由于第二个线程不能获得锁，将在调用lock方法时被阻塞。它必须等待第一个线程完成 transfer 方法的执行之后才能再度被激活。当第一个线程释放锁时，那么第二个线程才能开始运行（图14-5）。
- 尝试一下。添加锁代码到 transfer 方法并且再次运行程序。你可以永远运行它，而银行的余额不会出现讹误。
- 注意每一个Bank对象有自己的ReentrantLock对象。如果两个线程试图方法同一个Bank对象，那么**锁以串行方式**提供服务。但是，如果两个线程访问不同的Bank对象，每一个线程得到不同的锁对象，两个线程都不会发生阻塞。本该如此，因为线程在操作不同的Bank实例的时候，线程之间不会相互影响。
- 锁是**可重入**的，因为线程可以重复地获得已经持有的锁。锁保持一个**持有计数**（hold count）来跟踪对lock方法的嵌套调用。线程在每一次调用lock都要调用unlock来释放锁。由于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。
- 例如，transfer 方法调用 getTotalBalance 方法，这也会封锁 bankLock 对象，此时bankLock 对象的持有计数为 2。当getTotalBalance方法退出的时候，持有计数变回1。当transfer方法退出的时候，持有计数变为0。线程释放锁。
- 通常，可能想要保护需若干个操作来更新或检查共享对象的代码块。要确保这些操作完成后，另一个线程才能使用相同对象。
- ![3-1](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/pic/3-1.png)
- ![3-2](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/pic/3-2.png)
- **警告**：要留心临界区中的代码，不要因为异常的抛出而跳出了临界区。如果在临界区代码结束之前抛出了异常，finally子句将释放锁，但会使对象可能处于一种受损状态。
- API: java.util.concurrent.locks.Lock  5.0
- void lock()
> 获取这个锁；如果锁同时被另一个线程拥有则发生阻塞。
- void unlock()
> 释放这个锁。
- API: java.util.concurrent.locks.ReentrantLock 5.0
- ReentrantLock()
> 构建一个可以被用来保护临界区的可重入锁。
- ReentrantLock(boolean fair)
> 构建一个带有公平策略的锁。一个公平锁偏爱等待时间最长的线程。但是，这一公平的保证将大大降低性能。所以，默认情况下，锁没有被强制为公平的。
- **警告**：听起来公平锁更合理一些，但是使用公平锁比使用常规锁要慢很多。只有当你确实了解自己要做什么并且对于你要解决的问题有一个特定的理由必须要使用公平锁的时候，才可以使用公平锁。即使使用公平锁，也无法确保线程调度器是公平的。如果线程调度器选择忽略一个线程，而该线程为了这个锁已经等待了很长时间，那么就没有机会公平地处理这个锁了。
> 
### 14.5.4 条件对象
- 
### 14.5.5 synchronized 关键字
- 
### 14.5.6 同步阻塞
- 
### 14.5.7 监视器概念
- 
### 14.5.8 Volatile 域
- 
### 14.5.9 final 变量
- 
### 14.5.10 原子性
- 
### 14.5.11 死锁
- 
### 14.5.12 线程局部变量
-
### 14.5.13 锁测试与超时
- 
### 14.5.14 读/写锁
- 
### 14.5.15 为什么弃用stop和suspend方法
- 
