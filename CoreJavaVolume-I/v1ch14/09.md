### 14.9 执行器
- 构建一个新的线程是有一定代价的，因为涉及与操作系统的交互。如果程序中创建了大量的**生命期很短**的线程，应该使用**线程池**（thread pool）。一个线程池中包含许多准备运行的空闲线程。将 Runnable 对象交给线程池，就会有一个线程调用 run 方法。当run 方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务。
- 另一个使用线程池的理由是**减少并发线程的数目**。创建大量线程会大大降低性能甚至使虚拟机崩溃。如果有一个会创建许多线程的算法，应该使用一个线程数“固定的”线程池以限制并发线程的总数。
- **执行器**（Executor）类有许多静态工厂方法用来构建线程池。下面是一些执行者工厂方法：
- newCachedThreadPool                 必要时创建新线程；空闲线程会被保留60秒
- newFixedThreadPool                  该池包含固定数量的线程；空闲线程会一直被保留
- newSingleThreadExecutor             只有一个线程的“池”，该线程顺序执行每一个提交的任务（类似于Swing事件分配线程）
- newScheduledThreadPool              用于预订执行而构建的固定线程池，替代 java.util.Timer
- newSingleThreadScheduleExecutor     用于预定执行而构建的单线程“池”
> 
### 14.9.1 线程池
- newCachedThreadPool 方法构建了一个线程池，对于每个任务，如果有空闲线程可用，立即让它执行任务，如果没有可用的空闲线程，则创建一个新线程。newFixedThreadPool 方法构建一个具有固定大小的线程池。如果提交的任务数多于空闲的线程数，那么把得不到服务的任务放置到队列中。当其他任务完成以后再运行它们。 newSingleThreadExecutor 是一个退化了的大小为 1 的线程池：由一个线程执行提交的任务，一个接着一个。这 3 个方法返回实现了 ExecutorService 接口的 ThreadPoolExecutor 类的对象。
- 可用下面的方法之一将一个 Runnable 对象或 Callable 对象提交给 ExecutorService：
```
  Future<?> submit(Runnable task)
  Future<?> submit(Runnable task, T result)
  Future<?> submit(Callable<T> task)
```
- 该池会在方便的时候尽早执行提交的任务。调用 submit 时，会得到一个 Future 对象，可用来查询该任务的状态。
- 第一个submit方法返回一个奇怪样子的 Future\<?\>。可以使用这样一个对象来调用 isDone、cancel 或 isCancelled。但是，get方法在完成的时候只是简单地返回null。
- 第二个submit也提交一个Callable，并且Future的get方法在完成的时候返回指定的result对象。
- 第二个submit提交一个Callable，并且返回的Future对象将在计算结果准备好的时候得到它。
- 当用完一个线程池的时候，调用shutdown。该方法启动该池的关闭序列。被关闭的执行器不再接受新的任务。当所有任务都完成以后，线程池中的线程死亡。另一种方法是调用shutdownNow。该池取消尚未开始的所有任务并试图中断正在运行的线程。
- 下面总结了在使用连接池时应该做的事：
- 1）调用Executors 类中的静态方法 newCachedThreadPool 或 newFixedThreadPool。
- 2）调用submit 提交 Runnable 或 Callable 对象。
- 3）如果想要取消一个任务，或如果提交Callable对象，那就要保存好返回的Future对象。
- 4）当不再提交任何任务时，调用shutdown。
- 例如，前面的程序例子产生了大量的生命期很短的线程，每个目录产生一个线程。程序 [ThreadPoolTest.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch14/threadPool/ThreadPoolTest.java) 使用了一个线程池来运行任务。
- 出于信息方面的考虑，这个程序打印出执行池中最大的线程数。但是不能通过 ExecutorService 这个接口得到这一信息。因此，必须将该 pool 对象强制转换为 ThreadPoolExceutor 类对象。
- API: java.util.concurrent.Executors 5.0
- ExecutorService newCachedThreadPool()
> 返回一个带缓存的线程池，该池在必要的时候创建线程，在线程空闲 60 秒之后终止线程。
- ExecutorService newFixedThreadPool(int threads)
> 返回一个线程池，该池中的线程数由参数指定。
- ExecutorService newSingleThreadExecutor()
> 返回一个执行器，它在一个单个的线程中依次执行各个任务。
- API: java.util.concurrent.ExecutorService 5.0
- Future\<T\> submit(Callable\<T\> task)
- Future\<T\> submit(Runnable task, T result)
- Future\<T\> submit(Runnable task)
> 提交指定的任务去执行。
- void shutdown()
> 关闭服务，会先完成已经提交的任务而不再接收新的任务。
- API: java.util.concurrent.ThreadPoolExecutor  5.0
- int getLargestPoolSize()
> 返回线程池在该执行器生命周期中的最大尺寸。
>
### 14.9.2 预订执行
-
### 14.9.3 控制任务组
-
### 14.9.4 Fork-Join框架
-
