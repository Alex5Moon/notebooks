### 6.1 接口
- 在Java 程序设计语言中，接口不是类，而是对类的一组需求描述，这些类要遵从接口描述的统一格式进行定义。
- 我们常听到服务提供商这样说：“如果类遵从某个特定接口，那么就履行这项服务”。下面给出一个具体的示例。Arrays 类中的 sort 方法承诺可以对对象数组进行排序，但要求满足下列前提：对象所属的类必须实现了Comparable 接口。
- 下面是 Comparable 接口的代码：
```
  public interface Comparable{
    int compareTo(Object other);
  }
```
- 这就是说，任何实现 Comparable 接口的类都需要包含 compareTo 方法，并且这个方法的参数必须是一个 Object 对象，返回一个整型数值。
- 在 Java SE 5.0 中，Comparable 接口已经改进为泛型类型
```
  public interface Comparable<T>{
    int compareTo(T other);  // parameter has type T
  }
```
- 例如，在实现 Comparable<Employee> 接口的类中，必须提供下列方法
- ` int compareTo(Employee other)`
- 也可以使用没有类型参数的“原始”Comparable 类型，但必须手工地将 compareTo 方法的参数转换成所希望的类型。
- 接口中的所有方法自动地属于 public。因此，在接口中声明方法时，不必提供关键字 public。
- 当然，接口中还有一个没有明确说明的附加要求：在调用 x.compareTo(y) 的时候，这个 compareTo 方法必须确实比较两个对象的内容，并返回比较的结果。当x小于 y时，返回一个负数；当 x 等于 y 时，返回0；否则返回一个正数。
- 上面这个接口只有一个方法，而有些接口可能包含多个方法。稍后可以看到，在接口中还可以定义常量。然而，更为重要的是要知道接口不能提供哪些方法。接口绝不能含有实例域，也不能在接口中实现方法。提供实例域和方法实现的任务应该由实现接口的那个类来完成。因此，可以将接口看成是没有实例域的抽象类。但是这两个概念还是有一定区别的，稍后将给出详细解释。
- 现在，假设希望使用 Arrays 类的sort 方法对 Employee 对象数组进行排序，Employee 类就必须实现Comparable 接口。
- 为了让类实现一个接口，通常需要下面两个步骤：
- 1）将类声明为实现给定的接口。
- 2）对接口中的所有方法进行定义。
- 要将类声明为实现某个接口，需要使用关键字 implements：
- ` class Employee implements Comparable `
- 当然，这里的 Employee 类需要提供 compareTo 方法，假设希望根据雇员的薪水进行比较。一下是 compareTo 方法的实现：
```
  public int compareTo(Object otherObject){
    Employee other = (Employee) otherObject;
    return Double.compare(salary, other.salary);
  }
```
- 在这里，我们使用了静态 Double.compare 方法，如果第一个参数小于第二个参数，它会返回一个负值；如果二者相等则返回0；否则返回一个正值。
- 警告：在接口声明中，没有将 compareTo 方法声明为 public，这是因为在接口中的所有方法都自动地是 public。不过，在实现接口时，必须把方法声明为public；否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更弱的访问权限的警告信息。
- 在 Java SE 5.0 中，可以做得更好一些。可以将上面的实现替换为对 Comparable<Employee> 接口的实现。
```
  class Employee implements Comparable<Employee>{
    public int compareTo(Employee other){
      return Double.compare(salary, other.salary);
    }
  }
```
- 注意，将参数 Object 进行类型转换总是让人感觉不太舒服，但现在已经不见了。




