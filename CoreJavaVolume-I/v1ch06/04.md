### 6.4 内部类
- **内部类（inner class）** 是定义在另一个类中的类。为什么需要使用内部类呢？其主要原因有以下三点：
- 1）内部类方法可以访问该类定义所在的作用域中的数据，包括私有的数据。
- 2）内部类可以对同一个包中的其他类隐藏起来。
- 3）当想要定义一个回调函数且不想编写大量代码时，使用**匿名（anonymous）**内部类比较便捷。
- 我们将这个比较复杂的内容分几部分介绍。
- 在 6.4.1 中，给出一个简单的内部类，它将访问外围类的实例域。
- 在 6.4.2 中，给出内部类的特殊语法规则。
- 在 6.4.3 中，领域一下内部类的内部，探讨一下如何将其转换成常规类。
- 在 6.4.4 中，讨论**局部内部类**，它可以访问作用域中的局部变量。
- 在 6.4.5 中，讨论**匿名内部类**，说明用于实现回调的基本方法。
- 在 6.4.6 中，介绍如何将静态内部类嵌套在辅助类中。
### 6.4.1 使用内部类访问对象状态
- 内部类的语法比较复杂。鉴于此情况，我们选择一个简单但不太实用的例子说明内部类的使用方式。下面将进一步分析 TimerTest 示例，并抽象出一个 TalkingClock类，构造一个语音时钟需要提供两个参数：发布通告的间隔和开关铃声的标志。
```
  public class TalkingClock{
    private int interval;
    private boolean beep;
    
    public TalkingClock(int interval, boolean beep){...}
    public void start(){...}
    
    // an inner class
    public class TimePrinter implements ActionListener{
      ...
    }
  }
```
- 需要注意，这里的 TimePrinter 类位于 TalkingClock 类内部。这并不意味着每个 TalkingClock 都有一个 TimePrinter 实例域。如前所示，TimePrinter 对象是由 TalkingClock 类的方法构造。
- 下面是 TimePrinter 类的详细内容。需要注意的一点是，actionPerformed 方法在发出铃声之前检查了 beep 标志。
```
  public class TimePrinter implements ActionListener{
      public void actionPerformed(ActionEvent event){
        Date now = new Date();
        System.out.println("At the tone, the time is "+now);
        if(beep) Toolkit.getDefaultToolKit().beep();
      }
  }
```
- 令人惊讶的事情发生了。TimePrinter 类没有实例域或者名为 beep 的变量，取而代之的是 beep 引用了常见 TimePrinter 的 TalkingClock 对象的域。这是一种创新的想法。从传统意义上讲，一个方法可以引用调用这个方法的对象数据域。内部类既可以访问自身的数据域，也可以访问创建它的外围类对象的数据域。
- 为了能够运行这个程序，内部类的对象总有一个隐式引用，它指向了创建它的外部类对象。
- **内部类对象拥有一个对外部类对象的引用**。这个引用在内部类的定义中是不可见的。为了说明这个概念，我们将外围类对象的引用称为 outer。于是 actionPerformed 方法将等价于下列形式：
```
      public void actionPerformed(ActionEvent event){
        Date now = new Date();
        System.out.println("At the tone, the time is "+now);
        if(outer.beep) Toolkit.getDefaultToolKit().beep();
      }
```
- 外围类的引用在构造器中设置。编译器修改了所有的内部类的构造器。添加一个外围类引用的参数。因为 TimePrinter 类没有定义构造器，所以编译器为这个类生成一个默认的构造器，其代码如下：
```
  public TimePrinter(TalkingClock clock){    // automatically generated code
    outer = clock;
  }
```
- 注意：outer 不是 Java 的关键字。我们只是用它说明内部类中的机制。
- 当在 start 方法中创建了 TimePrinter 对象后，编译器就会将 this 引用传递给当前的语音时钟的构造器：
- ` ActionListener listener = new TimePrinter(this); // parameter automatically added`
- [InnerClassTest.java](https://github.com/Alex5Moon/notebooks/blob/master/CoreJavaVolume-I/v1ch06/innerClass/InnerClassTest.java) 一个测试内部类的完整程序。下面我们再看一下访问控制。如果有一个 TimePrinter 类是一个常规类，它就需要通过TalkingClock类的公有方法访问beep 标志，而使用内部类可以给予改进，即不必提供仅用于访问其他类的访问器。
- TimePrinter 类声明为私有的。这样一来，只有 TalkingClock 的方法才能够构造 TimePrinter 对象。只有内部类可以是私有类，而常规类只可以具有包可见性，或公有可见性。
> 
### 6.4.2 内部类的特殊语法规则
- 在上一节中，已经讲述了内部类有一个外围类的引用 outer。事实上，使用外围类引用的正规语法还要复杂一些。表达式 
- OuterClass.this
- 表示外围类的引用。例如，可以像下面这样编写 TimePrinter 内部类的 actionPerformed 方法：
```
      public void actionPerformed(ActionEvent event){
        ...
        if(TalkingClock.this.beep) Toolkit.getDefaultToolKit().beep();
      }  
```
- 反过来，可以采用下列语法格式更加明确地编写内部对象的构造器：
- outerObject.new InnerClass(construction parameters)
- 例如，
- ActionListener listener = this.new TimePrinter();
- 在这里，最新构造的 TimePrinter 对象的外围类引用被设置为创建内部类对象的方法中的 this 引用。这是一种最常见的情况。通常，this 限定词是多余的。不过，可以通过显式地命名将外围类引用设置为其他的对象。例如，如果 TimePrinter 是一个公有内部类，对于任意的语音时钟都可以构造一个 TimePrinter：
```
  TalkingClock jabberer = new TalkingClock(1000, true);
  TalkingClock.TimePrinter listener = jabberer.new TimePrinter();
```
- 需要注意，在外围类的作用域之外，可以这样引用内部类：
- OuterClass.InnerClass





