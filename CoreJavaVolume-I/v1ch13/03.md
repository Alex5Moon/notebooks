### 13.3 集合框架
- **框架**（framework）是一个类的集，它奠定了创建高级功能的基础。框架中包含很多超类，这些超类拥有非常有用的功能、策略和机制。框架使用者创建的子类可以扩展超类的功能，而不必重新创建这些基本的机制。例如，Swing 就是一种用户界面的机制。
- Java集合类库构成了集合类的框架。它为集合的实现者定义了大量的接口和抽象类，并且对其中的某些机制给予了描述，例如，迭代协议。正如前面几节所做的那样，可以使用这些集合类，而不必了解框架。但是，如果想要实现用于多种集合类型的泛型算法，或者是想要增加新的集合类型，了解一些框架的知识是很有帮助的。
- ![12](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/12.png)
- 集合有两个基本的接口：Collection 和 Map。可以使用下列方法向集合中插入元素：
- `boolean add(E element)`
- 但是，由于映射表保存的是键/值对，所以可以使用put方法进行插入。
- `V put(K key, V value)`
- 要想从集合中读取某个元素，就需要使用迭代器访问它们。然而，也可以用get方法从映射表读取值：
- `V get(K key)`
- List 是一个**有序集合**（ordered collection）。元素可以添加到容器中某个特定的位置。将对象放置在某个位置上可以采用两种方式：使用整数索引或使用列表迭代器。List 接口定义了几个用于随机访问的方法：
```
  void add(int index, E element)
  E get(int index)
  void remove(int index)
```
- 如同前面所讨论的，List 接口在提供这些随机访问方法时，并不管它们对某种特定的实现是否高效。为了避免执行成本较高的随机访问操作，Java SE 1.4 引入了一个标记接口 RandomAccess。这个接口没有任何方法，但可以用来检测一个特定的集合是否支持高效的随机访问：
```
  if (c instanceof RandomAccess) {
    use random access algorithm
  } else {
    use sequential access algorithm
  }
```
- ArrayList 类 和 Vector 类都实现了 RandomAccess 接口。
- ListIterator 接口定义了一个方法，用于将一个元素添加到迭代器所处位置的前面：
- `void add(E element)`
- 要想获取和删除给定位置的元素，只需要调用 Iterator 接口中的next 方法和 remove 方法即可。
- Set 接口与 Collection 接口是一样的，只是其方法的行为有着更加严谨的定义。Set 的 add 方法拒绝添加重复的元素。Set 的 equals 方法定义另个集相等的条件是它们包含相同的元素但顺序不必相同。hashCode 方法定义应该保证具有相同元素的集将会得到相同的散列码。
- 既然方法签名是相同的，为什么还要建立一个独立的接口呢？从概念上讲，并不是所有的的集合都是 Set。建立 Set 接口后，可以让程序员编写仅接受 Set 的方法。
- SortedSet 和 SortedMap 接口暴露了用于排序的比较器对象，并且定义的方法可以获得集合的子集视图。下一节将讨论这些视图。
- 最后，Java SE 6 引入了接口 NavigableSet 和 NavigableMap，其中包含了几个用于在有序集和映射表中查找和遍历的方法（从理论上讲，这几个方法已经包含在 SortedSet 和 SortedMap 的接口中）。TreeSet 和 TreeMap 类实现了这几个接口。
- 现在，让我们将话题从接口转到实现接口的类上。前面已经讨论过，集合接口有大量的方法，这些方法可以通过更基本的方法加以实现。抽象类提供了许多这样的例行实现：
```
  AbstractCollection
  AbstractList
  AbstractSequentialList
  AbstractSet
  AbstractQueue
  AbstractMap
```
- 如果实现了自己的集合类，就可能要扩展上面某个类，以便可以选择例行操作的实现。
- Java 类库支持下面几种具体类：
```
  LinkedList
  ArrayList
  ArrayQueue
  HashSet
  TreeSet
  PriorityQueue
  HashMap
  TreeMap
```
- ![13](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/13.png)
- 最后，还有许多 Java 第一版“遗留”下来的容器类，在集合框架出现就有了，它们是：
```
  Vector
  Stack
  Hashtable
  Properties
```
- 这些类已经被集成到集合框架中。
- ![14](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/14.png)
> 
### 13.3.1 视图与包装器
- 看下图13-10和图13-11可能会感觉：用如此多的接口和抽象类来实现数量并不多的具体集合类似乎没有太大必要。然而，这两张图并没有展示出全部的情况。通过使用**视图**（views）可以获得其他的实现了集合接口和映射表的接口的对象。映射表类的keySet方法就是一个这样的示例。初看起来，好像这个方法创建了一个新集，并将映射表中的所有键都填进去，然后返回这个集。但是，情况并非如此。取而代之的是：keySet方法返回一个实现Set接口的类对象，这个类的方法对原映射表进行操作。这种集合称为**视图**。
- 视图技术在集框架中有许多非常有用的应用。下面将讨论这些应用。
- 1 轻量级集包装器
- Arrays类的 asList 将返回一个包装了普通Java数组的 List 包装器。这个方法可以将数组传递给一个期望得到列表或集合变元的方法。例如：
```
  Card[] cardDeck = new Card[52];
  ...
  List<Card> cardList = Arrays.asList(cardDeck);
```
- 返回的对象不是 ArrayList。它是一个视图对象，带有底层数组的 get 和 set 方法。改变数组大小的所有方法（例如，与迭代器相关的 add 和 remove 方法），都会抛出一个 UnSupportedOperationException 异常。
- 从Java SE 5.0 开始，asList 方法声明为一个具有可变数量参数的方法。除了可以传递一个数组之外，还可以将各个元素直接传递给这个方法。例如：
- ` List<String> names = Arrays.asList("Amy", "Bob", "Carl");`
- 这个方法调用
- ` Collections.nCopies(n, anObject);`
- 将返回一个实现了 List 接口的不可修改的对象，并给人一种包含 n 个元素，每个元素都像是一个 anObject 的错觉。
- 例如，下面的调用将创建一个包含 100 个字符串的 List，每个串都被设置为 "DEFAULT":
- ` List<String> settings = Collections.nCopies(100, "DEFAULT");`
- 由于字符串对象只存储了一次，所以付出的存储代价很小。这是视图技术的一种巧妙的应用。
- **注释：**Collections 类包含很多实用方法，这些方法的参数和返回值都是集合。不要将它与Collection 接口混淆起来。
- 如果调用方法：
- ` Collections.singleton(anObject); `
- 则将返回一个视图对象。这个对象实现了 Set 接口（与产生 List 接口的 nCopies 方法不同）。返回的对象实现了一个不可修改的单元素集，而不需要付出建立数据结构的开销。singletonList 方法与 singletonMap 方法类似。
- 2 子范围
- 可以为很多集合建立子范围（subrange）视图。例如，假设有一个列表 staff，想从中取出第10个~第19个元素。可以使用 subList 方法来获得一个列表的子范围视图。
- ` List group2 = staff.subList(10, 20);`
- 第一个索引包含在内，第二个索引则不包含在内。这与 String 类的 substring 操作中的参数情况相同。
- 可以将任何操作应用于子范围，并且能够自动地反映整个列表的情况。例如，可以删除整个子范围：
- ` group2.clear();   // staff reduction`
- 现在，元素自动地从staff列表中清除了，并且 group2 为空。
- 对于有序集合和映射表，可以使用排序顺序而不是元素位置建立子范围。SortedSet 接口声明了3个方法：
```
  Sorted<E> subSet(E from, E no);
  Sorted<E> headSet(E to);
  Sorted<E> tailSet(E from);
```
- 这些方法将返回大于等于 from 且小于 to 的所有元素子集。有序映射表也有类似的方法：
```
  SortedMap<K, V> subMap(K from, K to);
  SortedMap<K, V> headMap(K to);
  SortedMap<K, V> tailMap(K from);
```
- 返回映射表视图，该映射表包含**键**落在指定范围内的所有元素。
- Java SE 6 引入的 NavigableSet 接口赋予子范围操作更多的控制能力。可以指定是否包含边界：
```
  NavigableSet<E> subSet(E from, boolean fromInclusive, E to, boolean toInclusive);
  NavigableSet<E> headSet(E to, boolean toInclusive);
  NavigableSet<E> tailSet(E from, boolean fromInclusive);
```
- 3 不可修改的视图
- Collections 还有几个方法，用于产生集合的**不可修改视图**（unmodifiable views）。这些视图对现有集合增加了一个运行时的检查。如果发现试图对集合进行修改，就抛出一个异常，同时这个集合将保持未修改的状态。
- 可以使用下面 6 种方法获得不可修改视图：
```
  Collections.unmodifiableCollection
  Collections.unmodifiableList
  Collections.unmodifiableSet
  Collections.unmodifiableSortedSet
  Collections.unmodifiableMap
  Collections.unmodifiableSortedMap
```
- 每个方法都定义于一个接口。例如， Collections.unmodifiableList 与 ArrayList、LinkedList 或者任何实现了 List接口的其他类一起协同工作。
- 例如，假设想要查看某部分代码，但又不触及某个集合的内容，就可以进行下列操作：
```
  List<String> staff = new LinkedList<>();
  ...
  lookAt(Collections.unmodifiableList(staff));
```
- Collections.unmodifiableList 方法将返回一个实现 List 接口的类对象。其访问器方法将从 staff 集合中获取值。当然，lookAt 方法可以调用 List 接口中的所有方法，而不只是访问器。但是所有的更改器方法（例如，add）已经重新定义为抛出一个 UnsupportedOperationException 异常，而不是将调用传递给底层集合。
- 不可修改视图并不是集合本身不可修改。仍然可以通过集合的原始引用（在这里是 staff ）对集合进行修改。并且仍然可以让集合的元素调用更改器方法。
- 由于视图只是包装了**接口**而不是实际的集合对象，所以只能访问接口中定义的方法。例如，LinkedList 类有一些非常方便的方法，addFirst 和 addLast，它们都不是 List 接口的方法，不能通过不可修改视图进行访问。
- **警告：**unmodifiableCollection 方法（与本节稍后讨论的 synchronizedCollection 和 checkedCollection 方法一样）将返回一个集合，它的 equals 方法不调用底层集合的 equals 方法。相反，它继承了 Object 类的 equals 方法，这个方法只是检测两个对象是否是同一个对象。如果将集或列表转换成集合，就再也无法检测其内容是否相同了。视图就是也这种方式运行的，因为内容是否相等的检测在分层结构的这一层上没有定义妥当。视图将以同样的方式处理 hashCode 方法。
- 然而，unmodifiableSet 类和 unmodifiableList 类却使用底层集合的equals方法和hashCode方法。
- 4 同步视图
-
- 5 检查视图
- 
- 6 关于可选操作的说明
- 
- 
### 13.3.2 批操作
- 
### 13.3.3 集合与数组之间的转换
- 
