### 13.4 算法
- 泛型集合接口有一个很大的优点，即算法只需要实现一次。例如，考虑一下计算集合中最大元素这样一个简单的算法。使用传统方式，程序设计人员可能会用循环实现这个算法。下面就是找出数组中最大元素的代码。
```
  if (a.length==0) throw new NoSuchElementException();
  T largest = a[0];
  for (int i = 1; i < a.length; i++)
    if (largest.compareTo(a[i]) < 0)
      largest = a[i];
```
- 当然，为找出数组列表中的最大元素所编写的代码会与此稍有差别。
```
  if (v.size()==0) throw new NoSuchElementException();
  T largest = v.get(0);
  for (int i = 1; i < v.size(); i++)
    if(largest.compareTo(v.get(i)) < 0)
      largest = v.get(i);
```
- 链表应该怎么做呢？对于链表来说，无法实施高效地随机访问，但却可以使用迭代器。
```
  if (l.isEmpty()) throw new NoSuchElementException();
  Iterator<T> iter = l.iterator();
  T largest = iter.next();
  while (iter.hasNext()){
    T next = iter.next();
    if (largest.compareTo(next) < 0)
      largest = next;
  }
```
- 编写这些循环代码有些乏味，并且也很容易出错。是否存在严重错误吗？对于空容器循环能正常工作吗？对于只含有一个元素的容器又会发生什么情况呢？我们不希望每次都测试和调试这些代码，也不想实现下面这一系列的方法：
```
  static <T extends Comparable> T max(T[] a)
  static <T extends Comparable> T max(ArrayList<T> v)
  static <T extends Comparable> T max(LinkedList<T> l)
```
- 这正是集合接口的用武之地。仔细考虑一下，为了高效地使用这个算法所需要的**最小**集合接口。采用get和set方法进行随机访问要比直接迭代层次高。在计算链表中最大元素的过程中已经看到，这项任务并不需要进行随机访问。直接用迭代器遍历每个元素就可以计算最大元素。因此，可以将 max 方法实现为能够接受任何实现了 Collection 接口的对象。
```
  public static <T extends Comparable> T max(Collection<T> c) {
    if (c.isEmpty()) throw new NoSuchElementException();
    Iterator<T> iter = c.iterator();
    T largest = iter.next();
    while (iter.hasNext()){
      T next = iter.next();
      if (largest.compareTo(next) < 0)
        largest = next;
    }
    return largest;
  }
```
- 现在就可以使用一个方法计算链表、数组列表或数组中最大元素了。
- 这是一个非常重要的概念。事实上，标准的 C++ 类库已经有几十种非常有用的算法，每个算法都是在泛型集合上操作的。Java 类库中的算法没有如此丰富，但是，也包含了基本的排序、二分查找等实用算法。
> 
### 13.4.1 排序与混排
- 计算机行业的前辈们有时会回忆起他们当年不得不使用穿孔卡片以及手工编写排序算法的情形。当然，如今排序算法已经成为大多数编程语言标准库中的一个组成部分，Java程序设计语言也不例外。
- Collecitons 类中的sort方法可以对实现了List接口的集合进行排序。
```
  List<String> staff = new LinkedList<>();
  fill collection
  Collections.sort(staff);
```
- 这个方法假定列表元素实现了Comparable接口。如果想采用其他方式对列表进行排序，可以将Comparator对象作为第二个参数传递给sort方法。下面的代码说明了对列表中各项进行排序的基本方法：
```
  Comparator<Item> itemComparator = new Comparator<Item>(){
    public int compare(Item a,Item b){
      return a.partNumber - b.partNumber;
    }
  };
  Collections.sort(items, itemComparator);
```
- 如果想按照**降序**对列表进行排序，可以使用一种非常方便的静态方法 Collections.reverseOrder()。这个方法将返回一个比较器，比较器则返回 b.compareTo(a)。例如，
- ` Collections.sort(staff, Collections.reverseOrder())`
- 这个方法将根据元素类型的 compareTo 方法给定排序顺序，按照逆序对列表 staff 进行排序。同样，
- ` Collections.sort(items, Collections.reverseOrder(itemComparator))`
- 将逆置 itemComparator 的次序。
- 人们可能会对 sort 方法所采用的排序手段感到好奇。通常，在翻阅有关算法书籍中的排序算法时，会发觉介绍的都是有关数组的排序算法，而且使用的是随机访问方式。但是，对列表进行随机访问的效率很低。实际上，可以使用归并排序对列表进行高效的排序（Robert Sedgewick 《Algorithms in C++》 P366~369）。然而，Java程序设计语言并不是这样实现的。它直接将所有元素转入一个数组，并使用一种归并排序的变体对数组进行排序，然后，再将排序后的序列复制回列表。
- 集合类库中使用的归并排序算法比快速排序要慢一些，快速排序是通用排序算法的传统选择。但是，归并排序有一个主要的优点：**稳定**，即不需要交换相同的元素。为什么要关注相同元素的顺序呢？下面是一种常见的情况。假设有一个已经按照姓名排列的员工列表。现在，要按照工资再进行排序。如果两个雇员的工资相等发生什么情况呢？如果采用稳定的排序算法，将会保留按名字排序的顺序。换句话说，排序的结果将会产生这样一个列表，首先按照工资排序，工资相同者再按照姓名排序。
- 因为集合不需要实现所有的“可选”方法，因此，所有接受集合参数的方法必须描述什么时候可以安全地将集合传递给算法。例如，显然不能将 unmodifiableList 列表传递给排序算法。**可以**传递什么类型的列表呢？根据文档说明，列表必须是可修改的，但不必是可以改变大小的。
- 下面是有关的术语定义：
- 如果列表支持set方法，则是**可修改**的。
- 如果列表支持add和remove方法，则是**可改变大小**的。
- Collections 类有一个算法shuffle，其功能与排序刚好相反，即随机地混排列表中元素的顺序。例如：
```
  ArrayList<Card> cards = ...;
  Collections.shuffle(cards);
```
- 如果提供的列表没有实现 RandomAccess接口，shuffle方法将元素复制到数组中，然后打乱数组元素的顺序，最后再将打乱顺序后的元素复制回列表。
- [ShuffleTest.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/shuffle/ShuffleTest.java) 中的程序用 1 ~ 49 之间的 49 个Integer对象填充数组。然后，随机地打乱列表，并从打乱后的列表中选前6个值。最后再将选择的数值进行排序和打印。
- API: java.util.Collections 1.2
- static \<T extends Comparable\<? super T\>\> void sort(List\<T\> elements)
- static \<T\> void sort(List\<T\> elements, Comparator\<? super T\> c)
> 使用稳定的排序算法，对列表中的元素进行排序。这个算法的时间复杂度是 O（n log n），其中 n 为列表的长度。
- static void shuffle(List\<?\> elements)
- static void shuffle(List\<?\> elements, Random r)
> 随机地打乱列表中的元素。这个算法的时间复杂度是 0（n a（n）），n 是列表的长度，a（n）是访问元素的平均时间。
- static \<T\> Comparator\<T\> reverseOrder()
> 返回一个比较器，它用于 Comparable 接口的 compareTo 方法规定的顺序的逆序对元素进行排序。
- static \<T\> Comparator\<T\> reverseOrder(Comparator\<T\> comp)
> 返回一个比较器，它用于 comp 给定的顺序的逆序对元素进行排序。
>
### 13.4.2 二分查找
- 
### 13.4.3 简单算法
- 
### 13.4.4 编写自己的算法
- 
