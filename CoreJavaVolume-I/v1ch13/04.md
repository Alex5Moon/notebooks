### 13.4 算法
- 泛型集合接口有一个很大的优点，即算法只需要实现一次。例如，考虑一下计算集合中最大元素这样一个简单的算法。使用传统方式，程序设计人员可能会用循环实现这个算法。下面就是找出数组中最大元素的代码。
```
  if (a.length==0) throw new NoSuchElementException();
  T largest = a[0];
  for (int i = 1; i < a.length; i++)
    if (largest.compareTo(a[i]) < 0)
      largest = a[i];
```
- 当然，为找出数组列表中的最大元素所编写的代码会与此稍有差别。
```
  if (v.size()==0) throw new NoSuchElementException();
  T largest = v.get(0);
  for (int i = 1; i < v.size(); i++)
    if(largest.compareTo(v.get(i)) < 0)
      largest = v.get(i);
```
- 链表应该怎么做呢？对于链表来说，无法实施高效地随机访问，但却可以使用迭代器。
```
  if (l.isEmpty()) throw new NoSuchElementException();
  Iterator<T> iter = l.iterator();
  T largest = iter.next();
  while (iter.hasNext()){
    T next = iter.next();
    if (largest.compareTo(next) < 0)
      largest = next;
  }
```
- 编写这些循环代码有些乏味，并且也很容易出错。是否存在严重错误吗？对于空容器循环能正常工作吗？对于只含有一个元素的容器又会发生什么情况呢？我们不希望每次都测试和调试这些代码，也不想实现下面这一系列的方法：
```
  static <T extends Comparable> T max(T[] a)
  static <T extends Comparable> T max(ArrayList<T> v)
  static <T extends Comparable> T max(LinkedList<T> l)
```
- 这正是集合接口的用武之地。仔细考虑一下，为了高效地使用这个算法所需要的**最小**集合接口。采用get和set方法进行随机访问要比直接迭代层次高。在计算链表中最大元素的过程中已经看到，这项任务并不需要进行随机访问。直接用迭代器遍历每个元素就可以计算最大元素。因此，可以将 max 方法实现为能够接受任何实现了 Collection 接口的对象。
```
  public static <T extends Comparable> T max(Collection<T> c) {
    if (c.isEmpty()) throw new NoSuchElementException();
    Iterator<T> iter = c.iterator();
    T largest = iter.next();
    while (iter.hasNext()){
      T next = iter.next();
      if (largest.compareTo(next) < 0)
        largest = next;
    }
    return largest;
  }
```
- 现在就可以使用一个方法计算链表、数组列表或数组中最大元素了。
- 这是一个非常重要的概念。事实上，标准的 C++ 类库已经有几十种非常有用的算法，每个算法都是在泛型集合上操作的。Java 类库中的算法没有如此丰富，但是，也包含了基本的排序、二分查找等实用算法。
> 
### 13.4.1 排序与混排
- 
### 13.4.2 二分查找
- 
### 13.4.3 简单算法
- 
### 13.4.4 编写自己的算法
- 
