### 13.2 具体的集合
- 这里并不打算更加详细地介绍所有的接口，但我们认为先介绍一下Java类库提供的具体数据结构还是很有用途的。透彻地介绍了人们想使用的类之后，再回过头研究一些抽象的概念，看一看集合框架组织这些类的方式。
> 
|  集合类型        |                     描述                             |
|:----------------|:-----------------------------------------------------|
|  ArrayList      | 一种可以动态增长和缩减的索引序列                        |
|  LinkedList     | 一种可以在任何位置进行高效地插入和删除操作的有序序列      |
|  ArrayDeque     | 一种用循环数组实现的双端队列                           |
|  HashSet        | 一种没有重复元素的无序集合                              |
|  TreeSet        | 一种有序集                                            |
|  EnumSet        | 一种包含枚举类型值的集                                 |
|  LinkedHashSet  | 一种可以记住元素插入次序的集                            |
|  PriorityQueue  | 一种允许高效删除最小元素的集合                          |
|  HashMap        | 一种存储键/值关联的数据结构                             |
|  TreeMap        | 一种键值有序排列的映射表                                |
|  EnumMap        | 一种键值属于枚举类型的映射表                            |
|  LinkedHashMap  | 一种可以记住键/值项添加次序的映射表                      |
|  WeakHashMap    | 一种其值无用武之地后可以被垃圾回收器回收的映射表          |
|  IdentityHashMap| 一种用 == 而不是用equals 比较键值的映射表               |
- 上面展示了Java类库中的集合，并简要描述了每个集合类的用途（鉴于简单起见，省略了将在多线程中介绍的线程安全集合）。除了以Map 结尾的类之外，其他类都实现了Collection接口。而以Map结尾的类实现了Map接口。
### 13.2.1 链表
- 有很多示例已经使用了数组以及动态的ArrayList类。然而，数组和数组列表都有一个重大的缺陷。这就是从数组的中间位置删除一个元素要付出很大的代价，其原因是数组中处于被删除元素之后的所有元素都要向数组的前段移动。在数组中间的位置上插入一个元素也是如此。
- ![4](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/4.png)
- 另外一个大家非常熟悉的数据结构——**链表**（linked list）解决了这个问题。尽管数组在连续的存储位置上存放对象引用，但链表却将每个对象存放在独立的结点中。每个结点还存放着序列中下一个结点的引用。在Java程序设计语言中，所有链表实际上都是**双向链接的**（doubly linked）——即每个结点还存放着指向前驱结点的引用。
- 从链表中间删除一个元素是一个很轻松的操作，即需要对被删除元素附近的结点更新一下即可。
- 你也许曾经在数据结构课程中学习过如何实现链表的操作。在链表中添加或删除元素时，绕来绕去的指针可能已经给人们留下了破坏的印象。如果真是如此，就会为Java集合类库提供一个类 LinkedList 而感到拍手称快。
- 在下面的代码示例中，先添加3个元素，然后再将第2个元素删除：
```
  List<String> staff = new LinkedList<>();  // LinkedList implements list
  staff.add("Amy");
  staff.add("Bob");
  staff.add("Carl");
  Iterator iter = staff.iterator();
  String first = iter.next(); // visit first element
  String second = iter.next(); // visit second element
  iter.remove();  // remove last visited element
```
- ![5](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/5.png)
- ![6](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/6.png)
- 但是，链表与泛型集合之间有一个重要的区别。链表是一个**有序集合**(ordered collection)，每个对象的位置十分重要。LinkedList.add 方法将对象添加到链表的尾部。但是，常常需要将元素添加到链表的中间。由于迭代器是描述集合中位置的，所以这种依赖于位置的 add 方法将由迭代器负责。只有对自然有序的集合使用迭代器添加元素才有实际意义。例如，下一节将要讨论的集（set）类型，其中的元素完全无序。因此，在 Iterator 接口中就没有 add 方法。相反地，集合类库提供了子接口 ListIterator，其中包含 add 方法：
```
  interface ListIterator<E> extends Iterator<E> {
    void add(E element);
    ...
  }
```
- 与Collection.add 不同，这个方法不返回 boolean 类型的值，它假定添加操作总会改变链表。另外，ListIterator 接口有两个方法，可以用来反向遍历链表。
```
  E previous()
  boolean hasPrevious()
```
- 与next 方法一样，previous 方法返回越过的对象。
- LinkedList 类的 listIterator 方法返回一个实现了 ListIterator 接口的迭代器对象。
- ` ListIterator<String> iter = staff.listIterator();`
- add 方法在迭代器位置之前添加一个新对象。例如，下面的代码将越过链表中的第一个元素，并在第二个元素之前添加 “Juliet”：
```
  List<String> staff = new LinkedList<>();  // LinkedList implements list
  staff.add("Amy");
  staff.add("Bob");
  staff.add("Carl");
  ListIterator<String> iter = staff.listIterator();
  iter.next();  // skip past first element
  iter.add("Juliet");
```
- ![7](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/pic/7.png)
- 如果多次调用 add 方法，将按照提供的次序把元素添加的链表中。它们被依次添加到迭代器当前位置之前。
- 当用一个刚刚由 Iterator 方法返回，并且指向链表表头的迭代器调用 add 操作时，新添加的元素将变成列表的新表头。当迭代器越过链表的最后一个元素时（即hasNext 返回 false），添加的元素将变成列表的新表尾。如果链表有 n 个元素，有 n+1 个位置可以添加新元素。这些位置与迭代器的 n+1 个可能的位置相对应。例如，如果链表包含 3 个元素，A、B、C，就有4个位置（标有|）可以插入新元素：
```
  |ABC
  A|BC
  AB|C
  ABC|
```
- **注释：**在用“光标”类比时要格外小心。remove 操作与 BACKSPACE 键的工作方式不太一样。在调用 next 之后，remove 方法确实与 BACKSPACE 键一样删除了迭代器左侧的元素。但是，如果调用 previous 就会将右侧的元素删除掉，并且不能在同一行中调用两次 remvoe。 add 方法只依赖于迭代器的位置，而 remove 方法依赖于迭代器的状态。
- 最后需要说明，set 方法用一个新元素取代调用 next 或 previous 方法返回的上一个元素。例如，下面的代码将用一个新值取代链表的第一个元素：
```
  ListIterator<String> iter = list.listIterator();
  String oldValue = iter.next();  // returns first element
  iter.set(newValue);     // sets first element to newValue
```
- 可以想象，如果在某个迭代器修改集合时，另一个迭代器对其进行遍历，一定会出现混乱的状况。例如，一个迭代器指向另一个迭代器刚刚删除的元素前面，现在这个迭代器就是无效的，并且不应该再使用。链表迭代器的设计使它能够检测到这种修改。如果迭代器发现它的集合被另一个迭代器修改了，或是被该集合自身的方法修改了，就会抛出一个 ConcurrentModificationException 异常。例如，看一看下面这段代码：
```
  List<String> list = ... ;
  ListIterator<String> iter1 = list.listIterator();
  ListIterator<String> iter2 = list.listIterator();
  iter1.next();
  iter1.remove();
  iter2.next();   // throws ConcurrentModificationException
```
- 由于 iter2 检测出这个链表被从外部修改了，所以对 iter2.next 的调用抛出了一个ConcurrentModificationException 异常。
- 为了避免发生**并发**修改的异常，请遵循下述简单规则：可以根据需要给容器附加许多的迭代器，但是这些迭代器只能读取列表。另外，再单独附加一个既能读又能写的迭代器。
- 有一种简单的方法可以检测到**并发**修改的问题。集合可以跟踪改写操作（诸如添加或删除元素）的次数。每个迭代器都维护一个独立的计数值。在每个迭代器方法的开始处检出自己改写操作的数值是否与集合的改写操作计数值一致。如果不一致，抛出一个 ConcurrentModificationException 异常。
- **注释：**对于并发修改列表的检测有一个奇怪的例外。链表只负责跟踪对列表的结构性修改，例如，添加元素、删除元素。set 操作不被视为结构性修改。可以将多个迭代器附加给一个链表，所有的迭代器都调用 set 方法对现有结点的内容进行修改。在本章后面所介绍的 Collections 类的许多算法都需要使用这个功能。
- 现在已经介绍了LinkedList 类的各种基本方法。可以使用 ListIterator 类从前后两个方法遍历链表中的元素，并可以添加、删除元素。
- 在上一节已经看到，Collection 接口中声明了许多用于对链表操作的有用方法。其中大部分方法都是在 LinkedList 类的超类 AbstractCollection 中实现的。例如， toString 方法调用所有元素的 toString，并产生了一个很长的格式为[A,B,C] 的字符串。这为调试工作提供了遍历。可以使用 contains 方法检测某个元素是否出现在链表中。例如，如果链表中包含一个等于“Harry” 的字符串，调用 staff.contains("Harry") 后将返回 true。
- 在 Java 类库中，还提供了许多在理论上存在一定争议的方法。链表不支持快速地随机访问。如果要查看链表中第 n 个元素，就必须从头开始，越过 n-1 个元素。没有捷径可走。鉴于这个原因，在程序需要采用整数索引访问元素时，程序员通常不选用链表。
- 尽管如此，LinkedList 类还是提供了一个用来访问某个特定元素的 get 方法：
```
  LinkedList<String> list = ... ;
  String obj = list.get(n);
```
- 当然，这个方法的效率并不太高。如果发现自己正在使用这个方法，说明有可能对于所要解决的问题使用了错误的数据结构。
- 绝对不应该使用这种让人误解的随机访问方法来遍历链表。下面这段代码的**效率极低**：
```
  for (int i = 0; i < list.size(); i++)
    do something with list.get(i);
```
- 每次查找一个元素都要从列表的头部重新开始搜索。LinkedList 对象根本不做任何缓存位置信息的操作。
- **注释：**get 方法做了微小的优化：如果索引大于 size()/2 就从列表尾端开始搜索元素。
- 列表迭代器接口还有一个方法，可以告之当前位置的索引。实际上，从概念上讲，由于 Java 迭代器指向两个元素之间的位置，所以可以同时产生两个索引：nextIndex 方法返回下一次调用 next 方法时返回元素的整数索引；previousIndex 方法返回下一次调用 previous 方法是返回元素的整数索引。当然，这个索引只比 nextIndex 返回的索引值小 1。这两个方法的效率非常高，这是因为迭代器保持着当前位置的计数值。最后需要说一下，如果有一个整数索引 n，list.listIterator(n) 将返回一个迭代器，这个迭代器指向索引为 n 的元素前面的位置。也就是说，调用 next 与调用 list.get(n) 会产生同一个元素，只是获得这个迭代器的效率比较低。
- 如果链表中只有很少几个元素，就完全没有必要为 get 方法和 set 方法的开销而烦恼。但是，为什么要优先使用链表呢？使用链表的唯一理由是尽可能地减少在列表中间插入或删除元素所付出的代价。如果列表只有少数几个元素，就完全可以使用 ArrayList。
- 建议避免使用以整数索引表示链表中位置的所有方法。如果需要对集合进行随机访问，就使用数组或 ArrayList，而不要使用链表。
- [LinkedListTest.java](https://github.com/lu666666/notebooks/blob/master/CoreJavaVolume-I/v1ch13/linkedList/LinkedListTest.java) 中的程序使用的就是链表。它简单地创建了两个链表，将它们合并在一起，然后从第二个链表中每间隔一个元素删除一个元素，最后测试 removeAll 方法。建议跟踪一下程序流程，并要特别注意迭代器。从这里会发现绘制一个下面这样的迭代器位置示意图是非常有用的：
```
  |ACE  |BDFG
  A|CE  |BDFG
  AB|CE B|DFG
  ...
```
- 注意调用 System.out.println(a);
- 通过调用AbstractCollection 类中的 toString 方法打印出链表 a 中的所有元素。
- API: java.util.List\<E\> 1.2
- API: java.util.ListIterator\<E\> 1.2
- API: java.util.LinkedList\<E\> 1.2

### 13.2.2 数组列表
- 
### 13.2.3 散列集
- 
### 13.2.4 树集
- 
### 13.2.5 对象的比较
- 
### 13.2.6 队列与双端队列
- 
### 13.2.7 优先级队列
- 
### 13.2.8 映射表
- 
### 13.2.9 专用集与映射表类
- 
