### 12.1 为什么要使用泛型程序设计
- **泛型程序设计**（Generic programming）意味着编写的代码可以被很多不同类型的对象所重用。例如，我们并不希望为聚集 String 和 File 对象分别设计不同的类。实际上，也不需要这样做，因为一个 ArrayList 类可以聚集任何类型的对象。这是一个泛型程序设计的实例。
- 在Java中增加泛型类之前，泛型程序设计使用**继承**实现的。ArrayList 类只维护一个Object 引用的数组：
```
  public class ArrayList { // before generic classes
    private Object[] elementData;
    ...
    public Object get(int i){...}
    public void add(Object o){...}
  }
```
- 这样的实现有两个问题。当获取一个值时必须进行强制类型转换。
```
  ArrayList files = new ArrayList();
  ...
  String filename = (String) files.get(0);
```
- 此外，这里没有错误检查。可以向数组列表中添加任何类的对象。
- ` files.add(new File("..."));`
- 对于这个调用，编译和运行都不会出错。然而在其他地方，如果将 get 的结果强制类型转换为 String 类型，就会产生一个错误。
- 泛型提供了一个更好的解决方案：**类型参数**（type parameters）。ArrayList 类有一个类型参数用来指示元素的类型：
- ` ArrayList<String> files = new ArrayList<String>();`
- 这使得代码具有更好的可读性。人们一看就知道这个数组列表中包含的是 String 对象。
- 编译器也可以很好地利用这个消息。当调用 get 的时候，不需要进行强制类型转换，编译器就知道返回值类型为 String，而不是 Object：
- ` String filename = files.get(0);`
- 编译器还知道 ArrayList<String> 中 add 方法有一个类型为 String 的参数。这将比使用 Object 类型的参数安全一些。现在，编译器可以进行检查，避免插入错误类型的对象。例如：
- ` files.add(new File("..."));  // can only add String objects to an ArrayList<String>`
- 是无法通过编译的。出现编译错误比类在运行时出现类的强制类型转换异常要好得多。类型参数的魅力在于：使得程序具有更好的可读性和安全性。
#### 谁想成为泛型程序员？
- 使用像 ArrayList 的泛型类很容易。大多数 Java 程序员都使用 ArrayList<String> 这样的类型，就好像它们已经构建在语言之中，像 String[] 数组一样。（当然，数组列表比数组要好一些，因为它可以自动扩展。）
- 但是，实现一个泛型类并没有那么容易。对于类型参数，使用这段代码的程序员可能想要内置（plug in）所有的类。他们希望在没有过多的限制以及混乱的错误消息的状态下，做所有的事情。因此，一个泛型程序员的任务就是预测出所用类的未来可能有的所有用途。
- 这一任务难到什么程度呢？下面是标准类库的设计者们肯定产生争议的一个典型问题。ArrayList 类有一个方法 addAll 用来添加另一个集合的全部元素。程序员可能想要将 ArrayList<Manager> 中的所有元素添加到 ArrayList<Employee> 中去。然而，反过来就不行了。如果只能允许前一个调用，而不能允许后一个调用呢？Java 语言的设计者发明了一个具有独创性的新概念，**通配符类型**（wildcard type），它解决了这个问题。通配符类型非常抽象，然而，它们能让库的构建者编写出尽可能灵活的方法。
- 泛型程序设计划分为 3 个能力级别。基本级别是，仅仅使用泛型类——典型的是像ArrayList 这样的集合——不必考虑它们的工作方式与原因。大多数应用程序员将会停留在这一级别上，直到出现了什么问题。当把不同的泛型类混合在一起时，或是在于对类型参数一无所知的遗留的代码进行衔接时，可能会看到含混不清的错误消息。如果这样的话，就需要学习Java 泛型来系统地解决这些问题，而不要胡乱地猜测。当然，最终可能想要实现自己的泛型类与泛型方法。
- 应用程序员很可能不喜欢编写太多的泛型代码。JDK 开发人员已经做出了很大的努力，为所有的集合类提供了类型参数。凭经验来说，那些原本涉及许多来自通用类型（如Object 或 Comparable 接口）的强制类型转换的代码一定会因使用类型参数而受益。
- 本章介绍实现自己的泛型代码需要了解的各种知识。希望大多数读者可以利用这些知识解决一些疑难问题，并满足对于参数化集合类的内部工作方式的好奇心。
