## 反射（Reflect）
##### Java 的一套内置API，是一套动态执行机制，可以实现动态功能：
- 动态加载类；
- 动态创建对象；
- 动态访问属性；
- 动态调用方法；
- ...
#### 常见框架的底层都使用了反射。
## 什么是反射（随需而变）
##### 是Java的动态执行机制
- 按部就班：静态执行
- 随需而变：动态执行
## 动态 与 静态
### 静态：经过 编译以后 ，就能够确定的调用关系称为静态！
```
String s = "abc";
System.out.println(s.length());
```
### 动态：在 运行期间 动态确定的调用关系称为动态！
- 使用反射API实现代码的动态调用：
![](https://github.com/lu666666/notebooks/blob/master/notes/10/2/7.png)
- 在程序运行期间可以动态的加载任意的类，动态的创建任意的对象，访问任意的属性，执行任意的方法。
### 为什么要用动态执行？什么时候必须使用动态执行？
#### 需求：创建一个无参数构造器类的对象，并且调用其全部以 test 为开头的无参数方法。
- 分析：类名不清楚，不能使用 new 类名()
- 不能调用方法：obj.方法()
>
- 结论：使用静态调用规则无法实现此需求！
- 如上需求必须使用反射API动态实现！
### 反射API提供了那些功能
### 动态加载类
- 根据任意的（可变的）类名，将这个类名对应的类文件（*.class） 文件加载到内存的方法区。
- Class.forName 方法加载类：先检查方法区内存中是否已经加载类，如果已经加载，就直接返回这个类信息，如果没有加载，再加载class文件到方法区。
![](https://github.com/lu666666/notebooks/blob/master/notes/10/2/1.png)
#### API
```
Class cls = Class.forName("类名");
//forName 将类加载到内存的方法区中
//cls 引用的对象就是连接到方法区中类信息的API对象。
```
#### 案例：
```
/*
 * 动态加载类到内存中
 */
Scanner in = new Scanner(System.in);
//运行期间从控制台“动态”获取“类名”
String className = in.nextLine();
//在程序运行之前， 是不指定类名是什么的
/*
 * 动态加载类到方法区中，当类名错误时候，
 * 类名对应的磁盘上没有class文件,就发生
 * 类没有找到异常！
 */
Class cls = Class.forName(className);
//检查加载的结果
System.out.println(cls); 
```
![](https://github.com/lu666666/notebooks/blob/master/notes/10/2/4.png)
#### 代码：
```
Class cls = Class.forName(类名);
```
#### 案例：
```
Scanner in = new Scanner(System.in);
/**
 * 从控制台读取被加载的类名：包名.类名
 */
String className = in.nextLine();
/**
 * 从硬盘上动态加载类"类名.class"。
 * 类加载到方法区，返回变量cls代表加载的
 * 结果。如果类名错误，Java反射API没有
 * 找到相应的类文件，就抛出:类没有找到异常
 */
Class cls = Class.forName(className);
//输出类加载的结果
System.out.println(cls);
```
### 动态加载类到方法区
- Class.forName() 方法会自动的到硬盘查找className对应的*.class文件，找到以后读取验证并且加载到方法区，加载结果为方法区中的类信息（类信息包括：构造器，属性，方法等），返回一个引用，利用这个引用可以访问类信息！
- 当类名错误时候出现异常：ClassNotFound
#### 代码示例：
```
Scanner in = new Scanner(System.in);
//运行期间动态获得类名
String className = in.nextLine();
//使用反射API动态加载类
Class cls=Class.forName(className);
System.out.println(cls);
```








