#### 刚才通过不断地建立线程测试 JavaVMStackOOM，-Xss 大小设置不当，直接电脑死机了，这一篇也没保存下来！！！教训
>
### 4 实战：OutOfMemoryError异常
>
- 在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（下文称OOM）异常的可能，
- 本节将通过若干实例来验证异常发生的场景，并且会初步介绍几个与内存相关的最基本的虚拟机参数。
>
- 本节内容的目的有两个：第一，通过代码**验证Java虚拟机规范中描述的各个运行时区域存储的内容**；
- 第二，希望在工作中遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。
>
### Java堆溢出（对象数量到达最大堆的容量限制）
>
- Java堆用于存储对象实例，只要**不断地创建对象**，并且**保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象**，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。
>
- 下面的代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），
- 通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。 
>
```
/**
 * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 * @author Administrator
 *
 */
public class HeapOOM {
	
	static class OOMObject{
		
	}
	
	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<OOMObject>();
		while(true){
			list.add(new OOMObject());
		}
	}

}

```
- 运行结果：
```
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid2792.hprof ...
Heap dump file created [28031244 bytes in 0.102 secs]
```
>
- Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。
- 要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如[Eclipse Memory Analyzer](https://blog.csdn.net/wizard_rp/article/details/73266194)）对Dump出来的堆转储快照进行分析，
- 重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了**内存泄漏**（Memory Leak）还是**内存溢出**（MemoryOverflow）。
>
- 如果是内存泄露，可进一步通过工具**查看泄露对象到GC Roots的引用链**。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。
- 掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。
>
- 如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），**与机器物理内存对比**看是否还可以调大，
- 从代码上检查**是否存在某些对象生命周期过长、持有状态时间过长**的情况，尝试减少程序运行期的内存消耗。
>
- 以上是处理Java堆内存问题的简单思路，处理这些问题所需要的知识、工具与经验是后面3章的主题。 
>
### 虚拟机栈和本地方法栈溢出
>
- 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，
- 但实际上是无效的，栈容量只由**-Xss参数**设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：
>
- 如果**线程请求的栈深度大于虚拟机所允许的最大深度**，将抛出StackOverflowError异常。
- 如果**虚拟机在扩展栈时无法申请到足够的内存空间**，则抛出OutOfMemoryError异常。
>
- 这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。
>
- 实验中，将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，
>
- 使用**-Xss参数减少栈内存容量**。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。
>
- 定义了大量的本地变量，**增大此方法帧中本地变量表的长度**。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。
>
```
/**
 * VM Args：-Xss128k
 * @author Administrator
 *
 */
public class JavaVMStackSOF {
	
	private int stackLength = 1;
	
	public void stackLeak(){
		stackLength++;
		stackLeak();
	}
	
	public static void main(String[] args) {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try{
			oom.stackLeak();
		}catch(Throwable e){
			System.out.println("stack length:"+oom.stackLength);
			throw e;
		}
	}	

}

```
- 运行结果：
```

```























