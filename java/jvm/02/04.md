#### 刚才通过不断地建立线程测试 JavaVMStackOOM，-Xss 大小设置不当，直接电脑死机了，这一篇也没保存下来！！！教训
>
### 4 实战：OutOfMemoryError异常
>
- 在Java虚拟机规范的描述中，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError（下文称OOM）异常的可能，
- 本节将通过若干实例来验证异常发生的场景，并且会初步介绍几个与内存相关的最基本的虚拟机参数。
>
- 本节内容的目的有两个：第一，通过代码**验证Java虚拟机规范中描述的各个运行时区域存储的内容**；
- 第二，希望在工作中遇到实际的内存溢出异常时，能根据异常的信息快速判断是哪个区域的内存溢出，知道什么样的代码可能会导致这些区域内存溢出，以及出现这些异常后该如何处理。
>
### Java堆溢出（对象数量到达最大堆的容量限制）
>
- Java堆用于存储对象实例，只要**不断地创建对象**，并且**保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象**，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。
>
- 下面的代码限制Java堆的大小为20MB，不可扩展（将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展），
- 通过参数-XX：+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。 
>
```
/**
 * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
 * @author Administrator
 *
 */
public class HeapOOM {
	
	static class OOMObject{
		
	}
	
	public static void main(String[] args) {
		List<OOMObject> list = new ArrayList<OOMObject>();
		while(true){
			list.add(new OOMObject());
		}
	}

}

```
- 运行结果：
```
java.lang.OutOfMemoryError: Java heap space
Dumping heap to java_pid2792.hprof ...
Heap dump file created [28031244 bytes in 0.102 secs]
```
>
- Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。
- 要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如[Eclipse Memory Analyzer](https://blog.csdn.net/wizard_rp/article/details/73266194)）对Dump出来的堆转储快照进行分析，
- 重点是确认内存中的对象是否是必要的，也就是要先分清楚到底是出现了**内存泄漏**（Memory Leak）还是**内存溢出**（MemoryOverflow）。
>
- 如果是内存泄露，可进一步通过工具**查看泄露对象到GC Roots的引用链**。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。
- 掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。
>
- 如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），**与机器物理内存对比**看是否还可以调大，
- 从代码上检查**是否存在某些对象生命周期过长、持有状态时间过长**的情况，尝试减少程序运行期的内存消耗。
>
- 以上是处理Java堆内存问题的简单思路，处理这些问题所需要的知识、工具与经验是后面3章的主题。 
>
### 虚拟机栈和本地方法栈溢出
>
- 由于在HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此，对于HotSpot来说，虽然-Xoss参数（设置本地方法栈大小）存在，
- 但实际上是无效的，栈容量只由**-Xss参数**设定。关于虚拟机栈和本地方法栈，在Java虚拟机规范中描述了两种异常：
>
- 如果**线程请求的栈深度大于虚拟机所允许的最大深度**，将抛出StackOverflowError异常。
- 如果**虚拟机在扩展栈时无法申请到足够的内存空间**，则抛出OutOfMemoryError异常。
>
- 这里把异常分成两种情况，看似更加严谨，但却存在着一些互相重叠的地方：当栈空间无法继续分配时，到底是内存太小，还是已使用的栈空间太大，其本质上只是对同一件事情的两种描述而已。
>
- 实验中，将实验范围限制于单线程中的操作，尝试了下面两种方法均无法让虚拟机产生OutOfMemoryError异常，尝试的结果都是获得StackOverflowError异常，
>
- 使用**-Xss参数减少栈内存容量**。结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。
>
- 定义了大量的本地变量，**增大此方法帧中本地变量表的长度**。结果：抛出StackOverflowError异常时输出的堆栈深度相应缩小。
>
```
/**
 * VM Args：-Xss128k
 * @author Administrator
 *
 */
public class JavaVMStackSOF {
	
	private int stackLength = 1;
	
	public void stackLeak(){
		stackLength++;
		stackLeak();
	}
	
	public static void main(String[] args) {
		JavaVMStackSOF oom = new JavaVMStackSOF();
		try{
			oom.stackLeak();
		}catch(Throwable e){
			System.out.println("stack length:"+oom.stackLength);
			throw e;
		}
	}	

}

```
- 运行结果：
```
stack length:985
Exception in thread "main" java.lang.StackOverflowError
	at jvm01_OOM.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:13)
	at jvm01_OOM.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14)
	at jvm01_OOM.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14)
	at jvm01_OOM.JavaVMStackSOF.stackLeak(JavaVMStackSOF.java:14)
	……后续异常堆栈信息省略
```
>
- 实验结果表明：在单个线程下，无论是由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError异常。
>
- 如果测试时不限于单线程，通过不断地建立线程的方式倒是可以产生内存溢出异常，如下代码所示。但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系，
- 或者准确地说，在这种情况下，**为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常**。
>
```
/**
 * VM Args：-Xss2M（这时候不妨设置大些）
 * 设置2M的时候电脑死机了，
 * @author Administrator
 *
 */
public class JavaVMStackOOM {
	
	private void dontStop(){
		while(true){
			
		}
	}
	
	public void stackLeakByThread(){
		while(true){
			Thread thread = new Thread(new Runnable(){

				@Override
				public void run() {
					// TODO Auto-generated method stub
					dontStop();
				}
				
			});
			
			thread.start();
		}
	}
	
	public static void main(String[] args) {
		JavaVMStackOOM oom = new JavaVMStackOOM();
		oom.stackLeakByThread();
	}
}


```
- 运行结果
>
```

```
>
- 注意　特别提示一下，如果读者要尝试运行上面这段代码，记得要先保存当前的工作。由于在Windows平台的虚拟机中，Java的线程是映射到操作系统的内核线程上的，因此上述代码执行时有较大的风险，可能会导致操作系统假死。
>
### 方法区和运行时常量池溢出
>
- 由于**运行时常量池是方法区的一部分**，因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情，在此就以测试代码观察一下这件事对程序的实际影响。
>
- String.intern（）是一个Native方法，它的作用是：
- 如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。
- 在JDK 1.6及之前的版本中，由于常量池分配在永久代内，我们可以通过-XX：PermSize和-XX：MaxPermSize限制方法区大小，从而间接限制其中常量池的容量，如下代码所示。

















