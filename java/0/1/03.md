### 03 final、finally、finalize有什么不同？
>
### 典型回答
>
- final 可以用来修饰类、方法、变量，分别有不同的意义，final 修饰的 class 代表不可以继承扩展，final 的变量是不可以修改的，而 final 的方法也是不可以重写的（override）。
>
- finally 则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭jdbc连接、保证unlock锁等动作。
>
- finalize 是基础类 java.lang.Object 的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize 机制现在已经不推荐使用，并且在jdk 9 开始被标记为deprecated。
>
### 考点分析
- 上面主要是从语法和使用实践角度出发的，其实还有很多方面可以深入探讨，还可以考察队性能、并发、对象生命周期或垃圾收集基本过程等方面的理解。
>
- 推荐使用 final 关键字来明确表示我们代码的语义、逻辑意图，这已经被证明在很多场景下是非常好的实践，比如：
- 将方法或者类声明为final，这样就可以明确告知别人，这些行为是不许修改的。
> java.lang 包下面的很多类，相当一部分类都被声明为 final class。在第三方类库的一些基础类中同样如此，这可以有效避免API使用者更改基础功能，某种程度上，这是保证平台安全的必要手段。
- 使用final修饰参数或者变量，也可以清楚地避免意外赋值导致的编程错误，甚至，有人明确推荐将所有方法参数、本地变量、成员变量声明成final。
- final变量产生了某种程度的不可变（immutable）的效果，所以，可以用于保护只读数据，尤其是在并发编程中，因为明确地不能在赋值final变量，有利于减少额外的同步开销，也可以省去一些防御性拷贝的必要。
> final 也许会有性能的好处，可以在特定场景提高性能，比如，利用final可能有助于jvm将方法进行内联，可以改善编译器进行条件编译的能力等等。坦白说，很多类似的结论都是基于假设得出的，比如现代高性能jvm（如HotSpot）判断内联未必依赖 final 的提示，要相信jvm还是非常智能的。类似的，final字段对性能的影响，大部分情况下，并没有考虑的必要。
- 在日常开发中，除非有特别考虑，不然最好不要指望这种小技巧带来的所谓性能好处。
>
- 对于 finally，明确知道怎么使用就足够了。需要关闭的连接等资源，更推荐使用Java 7中添加的 try-with-resources语句，因为通常Java平台能够更好地处理异常情况，编码量也要少很多，何乐而不为。
- 下面的代码会输出什么？
```
try {
  // do something
  System.exit(1);
} finally {
  System.out.println("Print from finally");
}
```
- 上面finally里面的代码可不会被执行，这是一个特例。
>
- 对于finalize，我们要明确它是不推荐使用的，业界实践一再证明它不是个好的方法，在Java 9中，甚至明确将 Object.finalize() 标记为 deprecated！如果没有特别的原因，不要实现finalize方法，也不要指望利用它来进行资源回收。
- 为什么呢？简单说，你无法保证finalize什么时候执行，执行的是否符合预期。使用不当会影响性能，导致程序死锁、挂起等。
- 通常来说，利用上面的提到的try-with-resources或者try-finally机制，是非常好的回收资源的办法。如果确实需要额外处理，可以考虑Java提供的Cleaner机制或者其他替代方法。
>
### 知识扩展
>
#### 1 注意，final不是immutable！
- 前面介绍了final在实践中的益处，需要注意的是，**final并不等同于immutable**，比如下面这段代码：
```
final List<String> strList = new ArrayList<>();
strList.add("Hello");
strList.add("world");
List<String> unmodifiableStrList = List.of("hello","world");
unmodifiableStrList.add("again");
```
- final 只能约束 strList 这个引用不可以被赋值，但是strList对象行为不被final影响，添加元素等操作是完全正常的。如果我们真的希望对象本身是不可变的，那么需要相应的类支持不可变的行为。在上面的代码中，List.of 方法创建的本身就是不可变List，最后那句 add 是会在运行时抛出异常的。
- immutable 在很多场景是非常棒的选择，某种意义上说，Java语言目前并没有原生的不可变支持，如果要实现immutable的类，我们需要做到：
- 1 将class自身声明为 final，这样别人就不能扩展来绕过限制了。
- 2 将所有成员变量定义为private和final，并且不要实现setter方法。
- 3 通常构造对象时，成员变量使用深度拷贝来初始化，而不是直接赋值，这是一种防御措施，因为你无法确定输入对象不被其他人修改。
- 4 如果确实需要实现getter方法，或者其他可能返回内部状态的方法，使用copy-on-write原则，创建私有的copy。
- 这些原则是不是在并发编程实践中经常被提到？的确如此。
- 关于 setter/getter 方法，很多人喜欢直接用 IDE 一次全部生成，建议最好是你确定有需要时再实现。
















